(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Observable'), require('rxjs/add/operator/map'), require('rxjs/add/operator/catch')) :
	typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Observable', 'rxjs/add/operator/map', 'rxjs/add/operator/catch'], factory) :
	(factory((global['thf-i18n-base'] = {}),global.Observable));
}(this, (function (exports,Observable) { 'use strict';

/**
 * \@description
 *
 * O pipe thf-i18n é responsável por tratar literais parâmetrizadas, dando mais flexibilidade as literais de tradução.
 * O número de parâmetros inseridos nas literais deve coincidir com a quantia de parâmetros passados por parâmetro,
 * os parâmetros serão substituidos de acordo com a ordem informada.
 *
 * Para inserir um parâmetro em uma literal, o mesmo deverá ser inserido entre chaves dentro da literal e posicionado
 * de acordo como deve ser exibido após a sua transformação.
 *
 * ```
 * const i18nPT = {
 *   pagination: 'Página {1} de {2} páginas.',
 *   totalPages: 'Total de {totalPages} encontradas.'
 * };
 * ```
 *
 * É possível passar um valor ou um array de valores para o pipe, caso seja passado um array, os valores devem obedecer a ordem
 * informada na literal.
 *
 * ```
 * {{ i18nPT.pagination | thfI18n:[1,10] }}
 * {{ i18nPT.totalPages | thfI18n:10 }}
 * ```
 */
var ThfI18nBasePipe = (function () {
    function ThfI18nBasePipe() {
    }
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    ThfI18nBasePipe.prototype.transform = function (value, args) {
        if (!value) {
            return '';
        }
        if (!(args instanceof Array)) {
            args = [args];
        }
        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
            var arg = args_1[_i];
            value = value.replace(/(\{\w*\})+/, arg);
        }
        return value;
    };
    return ThfI18nBasePipe;
}());

/**
 * \@description
 *
 * O serviço thfI18nService possibilita adicionar múltiplos idiomas e contextos à aplicação.
 *
 * A primeira configuração para a utilização do serviço thfI18nService é a importação do módulo
 * ThfI18nModule no módulo principal da aplicação.
 *
 * Ao importar o módulo ThfI18nModule devem ser definidos os contextos e idiomas que a aplicação
 * irá suportar, além de alguns padrões como idioma e contexto.
 *
 * No arquivo do módulo principal da aplicação deve ser definido uma constante implementando a
 * interface ThfI18nConfig. Nesta constante é possivel definir todos os contextos suportados pela
 * aplicação.
 *
 * Para cada contexto é possível definir a origem das literais, que podem ser de um serviço REST ou
 * de um objeto.
 * Exemplo:
 *
 * ```
 * import { ThfI18nConfig } from '\@totvs/thf-core/services/thf-i18n-base/thf-i18n-config.interface';
 *
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: {
 *       'pt-BR': GeneralPT,
 *       'en-US': GeneralEN
 *     },
 *     crm: {
 *       url: 'http://10.0.0.1:3000/api/translations/crm'
 *     }
 *   },
 *   default: {}
 * }
 * ```
 *
 * Ao optar por utilizar um serviço, deverá ser definida a URL específica do contexto,
 * como nos exemplos abaixo:
 *  - http://10.0.0.1:3000/api/translations/crm
 *  - http://10.0.0.1:3000/api/translations/general
 *
 * Os idiomas e literais serão automaticamente buscados com parâmetros na própria URL:
 * - language: o idioma será sempre passado por parâmetro e é recomendado utilizar o padrão suportado
 * pelos navegadores (pt-br, en-us)
 * - literals: as literais serão separadas por vírgula. Caso esse parâmetro não seja informado, o
 * serviço deve retornar todas as literais do idioma.
 *
 * Exemplos de requisição:
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br&literals=add,remove,text
 *
 * Obs: Sempre que o idioma solicitado não for encontrado, será buscado por "pt-br".
 *
 *
 * Conforme citado anteriormente, além dos contextos, é possível definir os padrões do sistema na
 * configuração do módulo:
 *  - language (string): idioma que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o idioma do navegador do usuário.
 *  - context (string): contexto que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o primeiro contexto da lista de contextos.
 *  - cache (boolean): define se as literais buscadas no serviço deverão ser armanezadas no cache do
 * navegador, lembrando que cada navegador possui sua própria limitação de cache. Para contextos com
 * grande quantidade de literais, recomenda-se o uso de constantes ao invés de serviços, desta forma
 * não será usado o cache do navegador.
 *
 * Exemplo de padrões definidos:
 * ```
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: { }
 *   },
 *   default: {
 *    language: 'pt-BR',
 *    context: 'general',
 *    cache: true
 *   }
 * }
 * ```
 *
 * Depois de criada a constante de configuração, deve-se passá-la para a função "config", diretamente
 * na importação do módulo.
 * ```
 *  imports: [
 *    ...
 *    ThfModule,
 *    ThfI18nModule.config(i18nConfig)
 *  ]
 * ```
 *
 * Feito isso, está finalizada a configuração do módulo e a aplicação está apta à utilizar o serviço
 * ThfI18nService.
 *
 * Para utilizar o serviço, deve-se importá-lo em todos os componentes que necessitarem de literais:
 * ```
 *  import { ThfI18nService } from '\@totvs/thf-web/services/thf-i18n/thf-i18n.service';
 * ```
 *
 * Em seguinda, fazer a injeção de dependência no construtor do componente:
 * ```
 *  constructor(private thfI18nService: ThfI18nService) { }
 * ```
 *
 * E por fim, fazer a busca pelas literais, se inscrevendo no Observable pelo método "getLiterals()".
 * Este método pode receber um objeto com três atributos como parâmetro:
 *  - context (string): Para definir o contexto a ser buscado.
 *  - language (string): Para escolher o idioma a ser buscado.
 *  - literals (Array&#60;string&#62;): Para escolher quais literais devem ser buscadas.
 *
 * Todos esses parâmetros são opcionais, ou seja, caso nenhum parâmetro seja passado, serão trazidas
 * todas as literais do contexto definido com padrão, no idioma definido como padrão.
 *
 * Exemplos de requisição:
 * ```
 * literals = {};
 * literalsEn = {};
 * literalsCrm = {};
 *
 * constructor(private thfI18nService: ThfI18nService) {
 *   thfI18nService.getLiterals()
 *     .subscribe((literals) => {
 *       this.literals = literals;
 *     });
 *
 *   thfI18nService.getLiterals({context: 'crm', literals: ['customer', 'supplier']})
 *     .subscribe((literals) => {
 *       this.literalsCrm = literals;
 *     });
 *
 *   thfI18nService.getLiterals({language: 'en-us'})
 *     .subscribe((literals) => {
 *       this.literalsEn = literals;
 *     });
 * }
 * ```
 *
 * Para apresentar as literais capturadas acima no HTML do componente, deve-se utilizar o
 * seguinte código:
 *
 * <pre ngNonBindable>
 * {{ literals?.add }}
 * {{ literals?.remove }}
 * </pre>
 *
 * Caso as literais contenham variáveis que precisem ser substituídas, pode-se utilizar o pipe thfI18n:
 *
 * <pre ngNonBindable>
 * {{ literals?.people | thfI18n:[qntPeople] }}
 * {{ literals?.greeting | thfI18n:[name, nickname] }}
 * </pre>
 *
 * > É importante o uso do operador "?" (Elvis) para evitar erros enquando as literais não forem carregadas.
 */
var ThfI18nBaseService = (function () {
    /**
     * @param {?} config
     * @param {?} http
     */
    function ThfI18nBaseService(config, http) {
        this.config = config;
        this.http = http;
        this.varI18n = {};
        this.useCache = false;
        this.servicesContext = {};
        this.setConfig(config);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    ThfI18nBaseService.prototype.setConfig = function (config) {
        // Seta as configurações padrões definidas no importação do módulo
        if (config['default']) {
            if (config['default']['language']) {
                this.languageDefault = config['default']['language'].toLowerCase();
            }
            else {
                this.languageDefault = navigator.language.toLowerCase();
            }
            this.contextDefault = (config['default']['context']) ? config['default']['context'] : '';
            this.useCache = (config['default']['cache']) ? config['default']['cache'] : false;
        }
        // Carrega a lista dos contextos e as contantes informadas
        if (config['contexts']) {
            this.setVarI18n(config['contexts']);
            // Se nenhum contexto foi definido como padrão,
            // então define o primeiro contexto
            if (!this.contextDefault) {
                for (var /** @type {?} */ context in config['contexts']) {
                    if (this.config['contexts'].hasOwnProperty(context)) {
                        this.contextDefault = context;
                        break;
                    }
                }
            }
        }
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiterals = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ language = (options['language']) ? options['language'].toLowerCase() : this.languageDefault.toLowerCase();
        var /** @type {?} */ context = (options['context']) ? options['context'] : this.contextDefault;
        var /** @type {?} */ literals = (options['literals']) ? options['literals'] : [];
        return new Observable.Observable(function (observer) {
            if (_this.servicesContext[context]) {
                // Faz o processo de busca de um contexto que contém serviço
                _this.getLiteralsFromContextService(language, context, literals, observer);
            }
            else {
                // Faz o processo de busca de um contexto que utiliza constante
                _this.getLiteralsFromContextConstant(language, context, literals, observer);
            }
        });
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsFromContextService = function (language, context, literals, observer, translations, languageAlternative) {
        if (translations === void 0) { translations = {}; }
        if (languageAlternative === void 0) { languageAlternative = null; }
        // Idioma usado para tentar buscar as literais faltantes
        var /** @type {?} */ languageSearch = (languageAlternative) ? languageAlternative : language;
        translations = this.mergeObject(translations, this.searchInVarI18n(languageSearch, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // Se foi pesquisado por literais
        if (literals.length > 0) {
            // Se não encontrou todas as literais pesquisadas no idioma
            if (literals.length > this.countObject(translations)) {
                this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
            }
        }
        else {
            this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
        }
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?} translations
     * @param {?=} languageAlternative
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsLocalStorageAndCache = function (language, context, literals, observer, translations, languageAlternative) {
        var _this = this;
        if (languageAlternative === void 0) { languageAlternative = null; }
        var /** @type {?} */ languageSearch = (languageAlternative) ? languageAlternative : language;
        var /** @type {?} */ translationTemp;
        // Verifica se usa cache
        if (this.useCache) {
            translationTemp = this.searchInLocalStorage(languageSearch, context, literals);
            if (this.countObject(translationTemp) > 0) {
                this.updateVarI18n(language, context, translationTemp);
                translations = this.mergeObject(translations, translationTemp);
                observer.next(translations);
            }
        }
        // Busca do Serviço
        this.getHttpService(this.servicesContext[context], languageSearch, literals)
            .subscribe(function (response) {
            if (response) {
                _this.updateLocalStorage(language, context, response);
                _this.updateVarI18n(language, context, response);
                translationTemp = _this.searchInVarI18n(language, context, literals);
                translations = _this.mergeObject(translations, translationTemp);
                observer.next(translations);
            }
            // Se não encontrou todas as literais pesquisadas no idioma
            // Então refaz o processo procurando em português
            if (literals.length > _this.countObject(translations)) {
                if (languageAlternative === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = _this.completeFaultLiterals(language, context, literals, translations);
                    _this.updateLocalStorage(language, context, translations);
                    _this.updateVarI18n(language, context, translations);
                    observer.next(translations);
                }
                else {
                    _this.getLiteralsFromContextService(language, context, literals, observer, translations, 'pt-br');
                }
            }
        });
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} observer
     * @param {?=} translations
     * @return {?}
     */
    ThfI18nBaseService.prototype.getLiteralsFromContextConstant = function (language, context, literals, observer, translations) {
        if (translations === void 0) { translations = {}; }
        translations = this.mergeObject(translations, this.searchInVarI18n(language, context, literals));
        if (this.countObject(translations) > 0) {
            observer.next(translations);
        }
        // Se foi pesquisado por literais
        if (literals.length > 0) {
            // Se não encontrou todas as literais pesquisadas no idioma, procura em português
            if (literals.length > this.countObject(translations)) {
                if (language === 'pt-br') {
                    // Se não encontrou nem em português, então retorna o nome das literais
                    translations = this.completeFaultLiterals(language, context, literals, translations);
                    observer.next(translations);
                }
                else {
                    this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
                }
            }
        }
        else {
            // Se não encontrar nenhuma literal, procura em português
            if (this.countObject(translations) === 0 && language !== 'pt-br') {
                this.getLiteralsFromContextConstant('pt-br', context, literals, observer, translations);
            }
        }
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.searchInLocalStorage = function (language, context, literals) {
        var /** @type {?} */ translations = {};
        if (literals.length > 0) {
            for (var /** @type {?} */ i = 0; i < literals.length; i++) {
                var /** @type {?} */ literal = literals[i];
                var /** @type {?} */ translation = localStorage.getItem(language + '-' + context + '-' + literal);
                if (translation) {
                    translations[literal] = translation;
                }
            }
        }
        return translations;
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.searchInVarI18n = function (language, context, literals) {
        var /** @type {?} */ translations = {};
        if (this.varI18n[language] && this.varI18n[language][context]) {
            var /** @type {?} */ content = this.varI18n[language][context];
            if (literals.length > 0) {
                // Busca as literais desejadas
                for (var /** @type {?} */ i = 0; i < literals.length; i++) {
                    var /** @type {?} */ literal = literals[i];
                    if (content.hasOwnProperty(literal)) {
                        translations[literal] = content[literal];
                    }
                }
            }
            else {
                // Atribui todas as literais
                translations = content;
            }
        }
        return translations;
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    ThfI18nBaseService.prototype.updateLocalStorage = function (language, context, data) {
        if (this.useCache) {
            for (var /** @type {?} */ literal in data) {
                if (data.hasOwnProperty(literal)) {
                    localStorage.setItem(language + '-' + context + '-' + literal, data[literal]);
                }
            }
        }
    };
    /**
     * @param {?} contexts
     * @return {?}
     */
    ThfI18nBaseService.prototype.setVarI18n = function (contexts) {
        // Percorre os contextos
        for (var /** @type {?} */ context in contexts) {
            if (contexts.hasOwnProperty(context)) {
                for (var /** @type {?} */ language in contexts[context]) {
                    if (contexts[context].hasOwnProperty(language)) {
                        var /** @type {?} */ languageContent = contexts[context][language];
                        if (language === 'url') {
                            this.servicesContext[context] = languageContent;
                        }
                        else {
                            this.updateVarI18n(language, context, languageContent);
                        }
                    }
                }
            }
        }
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} data
     * @return {?}
     */
    ThfI18nBaseService.prototype.updateVarI18n = function (language, context, data) {
        language = language.toLowerCase();
        if (!this.varI18n[language]) {
            this.varI18n[language] = (_a = {}, _a[context] = {}, _a);
        }
        if (!this.varI18n[language][context]) {
            this.varI18n[language][context] = {};
        }
        // Cria ou atualiza o contexto dentro do storage
        this.varI18n[language][context] = this.mergeObject(data, this.varI18n[language][context]);
        var _a;
    };
    /**
     * @param {?} url
     * @param {?} language
     * @param {?} literals
     * @return {?}
     */
    ThfI18nBaseService.prototype.getHttpService = function (url, language, literals) {
        var /** @type {?} */ param = '?language=' + language;
        if (literals.length > 0) {
            param += '&literals=' + literals.join();
        }
        // Remove a barra final do endereço
        url = (url.lastIndexOf('/') === url.length - 1) ? url.substr(0, url.length - 1) : url;
        return this.http.get(url + param)
            .map(function (response) { return response.json(); });
    };
    /**
     * @param {?} language
     * @param {?} context
     * @param {?} literals
     * @param {?} translations
     * @return {?}
     */
    ThfI18nBaseService.prototype.completeFaultLiterals = function (language, context, literals, translations) {
        for (var /** @type {?} */ i = 0; i < literals.length; i++) {
            var /** @type {?} */ literal = literals[i];
            if (!translations[literal]) {
                translations[literal] = literal;
            }
        }
        return translations;
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    ThfI18nBaseService.prototype.countObject = function (obj) {
        return Object.keys(obj).length;
    };
    /**
     * @param {?} objPermanent
     * @param {?} obj
     * @return {?}
     */
    ThfI18nBaseService.prototype.mergeObject = function (objPermanent, obj) {
        for (var /** @type {?} */ literal in objPermanent) {
            if (objPermanent.hasOwnProperty(literal)) {
                obj[literal] = objPermanent[literal];
            }
        }
        return obj;
    };
    return ThfI18nBaseService;
}());

exports.ThfI18nBasePipe = ThfI18nBasePipe;
exports.ThfI18nBaseService = ThfI18nBaseService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
