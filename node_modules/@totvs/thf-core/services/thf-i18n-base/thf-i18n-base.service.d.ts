import { Http } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import { ThfI18nLiterals } from './thf-i18n-literals.interface';
/**
 * @description
 *
 * O serviço thfI18nService possibilita adicionar múltiplos idiomas e contextos à aplicação.
 *
 * A primeira configuração para a utilização do serviço thfI18nService é a importação do módulo
 * ThfI18nModule no módulo principal da aplicação.
 *
 * Ao importar o módulo ThfI18nModule devem ser definidos os contextos e idiomas que a aplicação
 * irá suportar, além de alguns padrões como idioma e contexto.
 *
 * No arquivo do módulo principal da aplicação deve ser definido uma constante implementando a
 * interface ThfI18nConfig. Nesta constante é possivel definir todos os contextos suportados pela
 * aplicação.
 *
 * Para cada contexto é possível definir a origem das literais, que podem ser de um serviço REST ou
 * de um objeto.
 * Exemplo:
 *
 * ```
 * import { ThfI18nConfig } from '@totvs/thf-core/services/thf-i18n-base/thf-i18n-config.interface';
 *
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: {
 *       'pt-BR': GeneralPT,
 *       'en-US': GeneralEN
 *     },
 *     crm: {
 *       url: 'http://10.0.0.1:3000/api/translations/crm'
 *     }
 *   },
 *   default: {}
 * }
 *```
 *
 * Ao optar por utilizar um serviço, deverá ser definida a URL específica do contexto,
 * como nos exemplos abaixo:
 *  - http://10.0.0.1:3000/api/translations/crm
 *  - http://10.0.0.1:3000/api/translations/general
 *
 * Os idiomas e literais serão automaticamente buscados com parâmetros na própria URL:
 * - language: o idioma será sempre passado por parâmetro e é recomendado utilizar o padrão suportado
 * pelos navegadores (pt-br, en-us)
 * - literals: as literais serão separadas por vírgula. Caso esse parâmetro não seja informado, o
 * serviço deve retornar todas as literais do idioma.
 *
 * Exemplos de requisição:
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br
 *  - http://10.0.0.1:3000/api/translations/crm?language=pt-br&literals=add,remove,text
 *
 * Obs: Sempre que o idioma solicitado não for encontrado, será buscado por "pt-br".
 *
 *
 * Conforme citado anteriormente, além dos contextos, é possível definir os padrões do sistema na
 * configuração do módulo:
 *  - language (string): idioma que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o idioma do navegador do usuário.
 *  - context (string): contexto que será buscado por padrão pelo serviço, caso não seja especificado
 * será usado o primeiro contexto da lista de contextos.
 *  - cache (boolean): define se as literais buscadas no serviço deverão ser armanezadas no cache do
 * navegador, lembrando que cada navegador possui sua própria limitação de cache. Para contextos com
 * grande quantidade de literais, recomenda-se o uso de constantes ao invés de serviços, desta forma
 * não será usado o cache do navegador.
 *
 * Exemplo de padrões definidos:
 * ```
 * const i18nConfig: ThfI18nConfig = {
 *   contexts: {
 *     general: { }
 *   },
 *   default: {
 *    language: 'pt-BR',
 *    context: 'general',
 *    cache: true
 *   }
 * }
 * ```
 *
 * Depois de criada a constante de configuração, deve-se passá-la para a função "config", diretamente
 * na importação do módulo.
 * ```
 *  imports: [
 *    ...
 *    ThfModule,
 *    ThfI18nModule.config(i18nConfig)
 *  ]
 * ```
 *
 * Feito isso, está finalizada a configuração do módulo e a aplicação está apta à utilizar o serviço
 * ThfI18nService.
 *
 * Para utilizar o serviço, deve-se importá-lo em todos os componentes que necessitarem de literais:
 * ```
 *  import { ThfI18nService } from '@totvs/thf-web/services/thf-i18n/thf-i18n.service';
 * ```
 *
 * Em seguinda, fazer a injeção de dependência no construtor do componente:
 * ```
 *  constructor(private thfI18nService: ThfI18nService) { }
 * ```
 *
 * E por fim, fazer a busca pelas literais, se inscrevendo no Observable pelo método "getLiterals()".
 * Este método pode receber um objeto com três atributos como parâmetro:
 *  - context (string): Para definir o contexto a ser buscado.
 *  - language (string): Para escolher o idioma a ser buscado.
 *  - literals (Array&#60;string&#62;): Para escolher quais literais devem ser buscadas.
 *
 * Todos esses parâmetros são opcionais, ou seja, caso nenhum parâmetro seja passado, serão trazidas
 * todas as literais do contexto definido com padrão, no idioma definido como padrão.
 *
 * Exemplos de requisição:
 * ```
 * literals = {};
 * literalsEn = {};
 * literalsCrm = {};
 *
 * constructor(private thfI18nService: ThfI18nService) {
 *   thfI18nService.getLiterals()
 *     .subscribe((literals) => {
 *       this.literals = literals;
 *     });
 *
 *   thfI18nService.getLiterals({context: 'crm', literals: ['customer', 'supplier']})
 *     .subscribe((literals) => {
 *       this.literalsCrm = literals;
 *     });
 *
 *   thfI18nService.getLiterals({language: 'en-us'})
 *     .subscribe((literals) => {
 *       this.literalsEn = literals;
 *     });
 * }
 * ```
 *
 * Para apresentar as literais capturadas acima no HTML do componente, deve-se utilizar o
 * seguinte código:
 *
 * <pre ngNonBindable>
 * {{ literals?.add }}
 * {{ literals?.remove }}
 * </pre>
 *
 * Caso as literais contenham variáveis que precisem ser substituídas, pode-se utilizar o pipe thfI18n:
 *
 * <pre ngNonBindable>
 * {{ literals?.people | thfI18n:[qntPeople] }}
 * {{ literals?.greeting | thfI18n:[name, nickname] }}
 * </pre>
 *
 * > É importante o uso do operador "?" (Elvis) para evitar erros enquando as literais não forem carregadas.
 */
export declare class ThfI18nBaseService {
    private config;
    private http;
    private varI18n;
    private languageDefault;
    private contextDefault;
    private useCache;
    private servicesContext;
    constructor(config: any, http: Http);
    private setConfig(config);
    getLiterals(options?: ThfI18nLiterals): Observable<object>;
    private getLiteralsFromContextService(language, context, literals, observer, translations?, languageAlternative?);
    private getLiteralsLocalStorageAndCache(language, context, literals, observer, translations, languageAlternative?);
    private getLiteralsFromContextConstant(language, context, literals, observer, translations?);
    private searchInLocalStorage(language, context, literals);
    private searchInVarI18n(language, context, literals);
    private updateLocalStorage(language, context, data);
    private setVarI18n(contexts);
    private updateVarI18n(language, context, data);
    private getHttpService(url, language, literals);
    private completeFaultLiterals(language, context, literals, translations);
    private countObject(obj);
    private mergeObject(objPermanent, obj);
}
