import { ElementRef, EventEmitter, HostListener, Input, Optional, Output, ViewChild } from '@angular/core';
import { NgControl, Validators } from '@angular/forms';
import { convertToBoolean } from './../../../utils/index';
import { ThfMask } from './thf-mask';
/**
 * \@description
 *
 * Este é um componente baseado em input, com várias propriedades do input padrão e várias outras
 * propriedades extras como: máscara, pattern, mensagem de erro e etc.
 * Você deve informar a variável que contém o valor como [(ngModel)]="variavel", para que o
 * input receba o valor da variável e para que ela receba as alterações do valor (two-way-databinding).
 * A propriedade name é obrigatória para que o formulário e o model funcionem corretamente.
 *
 * Importante:
 * - Caso o input não esteja dentro de um form, é preciso adicionar ngDefaultControl ao componente:
 * Exemplo: [(ngModel)]="pessoa.nome" name="nome" ngDefaultControl
 *
 * - Caso o input esteja passando um [(ngModel)], mas não tenha um name, então irá ocorrer um erro
 * de angular. Então você precisa informar o atributo name ou o seguinte atributo
 * [ngModelOptions]="{standalone: true}".
 * Exemplo: [(ngModel)]="pessoa.nome" [ngModelOptions]="{standalone: true}"
 */
var ThfInputBaseComponent = (function () {
    /**
     * @param {?} el
     * @param {?=} ngControl
     */
    function ThfInputBaseComponent(el, ngControl) {
        /**
         * Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido
         */
        this.placeholder = '';
        /**
         * Indica que o campo será desabilitado
         */
        this.disabled = false;
        /**
         * Indica que o campo será somente leitura
         */
        this.readonly = false;
        /**
         * Indica que o campo será obrigatório
         */
        this.required = false;
        /**
         * Indica que o campo iniciará com foco
         */
        this.focus = false;
        /**
         * Indica se o campo terá a opção de limpa-lo
         * Opções:
         *  "" : para limpar o campo e atribuir "" para o model
         *  "undefined" : para limpar o campo e atribuir undefined para o model
         *  qualquer valor : para atribuir este valor ao campo e ao model
         */
        this.clean = '';
        /**
         * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
         * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido
         */
        this.errorPattern = '';
        /**
         * Indica máscara que o campo vai receber. Exemplo: (+99) (99) 99999?-9999
         * A máscara poderá ser validada por um pattern diferente da máscara informada, usando
         * a propriedade t-pattern.
         * O campo sendo obrigatório (t-required), será sinalizado quando estiver fora do padrão definido.
         */
        this.mask = '';
        /**
         * Indica se o model receberá o valor formatado ou puro. Padrão valor puro 'false'.
         */
        this.maskFormatModel = false;
        /**
         * Evento disparado ao sair do campo
         */
        this.blur = new EventEmitter();
        /**
         * Evento disparado ao entrar do campo
         */
        this.enter = new EventEmitter();
        /**
         * Evento disparado ao alterar valor e deixar o campo
         */
        this.change = new EventEmitter();
        /**
         * Evento disparado ao alterar valor do model
         */
        this.changeModel = new EventEmitter();
        this.type = 'text';
        this.validators = {};
        this.onChangePropagate = null;
        this.onTouched = null;
        this.fireChange = false;
        this.el = el;
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfInputBaseComponent.prototype, "setName", {
        /**
         * @param {?} name
         * @return {?}
         */
        set: function (name) {
            this.name = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setDisabled", {
        /**
         * @param {?} disabled
         * @return {?}
         */
        set: function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
            // Atualiza Validador do campo
            this.validators['required'] = this.getValidatorRequired();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setReadonly", {
        /**
         * @param {?} readonly
         * @return {?}
         */
        set: function (readonly) {
            this.readonly = readonly === '' ? true : convertToBoolean(readonly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
            // Atualiza Validador do campo
            this.validators['required'] = this.getValidatorRequired();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setFocus", {
        /**
         * @param {?} focus
         * @return {?}
         */
        set: function (focus) {
            this.focus = focus === '' ? true : convertToBoolean(focus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setClean", {
        /**
         * @param {?} clean
         * @return {?}
         */
        set: function (clean) {
            this.clean = 'null';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setPattern", {
        /**
         * @param {?} pattern
         * @return {?}
         */
        set: function (pattern) {
            this.pattern = pattern;
            // Atualiza Validador do campo
            this.validators['pattern'] = this.getValidatorPattern();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMaxlength", {
        /**
         * @param {?} maxlength
         * @return {?}
         */
        set: function (maxlength) {
            if (!isNaN(parseInt(maxlength, 10))) {
                this.maxlength = parseInt(maxlength, 10);
                // Atualiza Validador do campo
                this.validators['maxlength'] = this.getValidatorMaxlength();
                this.updateValidators();
            }
            else if (maxlength === undefined) {
                this.maxlength = undefined;
                // Atualiza Validador do campo
                this.validators['maxlength'] = this.getValidatorMaxlength();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMinlength", {
        /**
         * @param {?} minlength
         * @return {?}
         */
        set: function (minlength) {
            if (!isNaN(parseInt(minlength, 10))) {
                this.minlength = parseInt(minlength, 10);
                // Atualiza Validador do campo
                this.validators['minlength'] = this.getValidatorMinlength();
                this.updateValidators();
            }
            else if (minlength === undefined) {
                this.minlength = undefined;
                // Atualiza Validador do campo
                this.validators['minlength'] = this.getValidatorMinlength();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMask", {
        /**
         * @param {?} mask
         * @return {?}
         */
        set: function (mask) {
            this.mask = mask;
            if (this.objMask instanceof ThfMask) {
                // Atualiza Máscara do Campo
                this.objMask = new ThfMask(this.mask, this.maskFormatModel);
                // Atualiza Validador do campo
                this.validators['pattern'] = this.getValidatorPattern();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMaskFormatModel", {
        /**
         * @param {?} maskFormatModel
         * @return {?}
         */
        set: function (maskFormatModel) {
            this.maskFormatModel = maskFormatModel === '' ? true : convertToBoolean(maskFormatModel);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.ngOnInit = function () {
        this._onInit();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.ngAfterViewInit = function () {
        this._afterViewInit();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype._onInit = function () {
        // Classe de máscara
        this.objMask = new ThfMask(this.mask, this.maskFormatModel);
        this.setValidators();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype._afterViewInit = function () {
        // Põe o foco no Input, setado pelo t-focus
        if (this.focus) {
            this.inputEl.nativeElement.focus();
        }
        if (this.clean) {
            this.inputEl.nativeElement.style.paddingRight = '30px';
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.setValidators = function () {
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            // Validações do campo. Estas validações que irão tornar o campo e o formulário válidos ou inválidos
            this.validators = {};
            this.validators['required'] = this.getValidatorRequired();
            this.validators['pattern'] = this.getValidatorPattern();
            this.validators['minlength'] = this.getValidatorMinlength();
            this.validators['maxlength'] = this.getValidatorMaxlength();
            this.updateValidators();
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorRequired = function () {
        return (!this.disabled && this.required) ? Validators.required : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorPattern = function () {
        if (this.pattern) {
            return Validators.pattern(this.pattern);
        }
        else if (this.mask) {
            var /** @type {?} */ patternToMask = this.objMask.getRegexFromMask(this.mask);
            return Validators.pattern(patternToMask);
        }
        return null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorMinlength = function () {
        return (this.minlength) ? Validators.minLength(this.minlength) : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorMaxlength = function () {
        return (this.maxlength) ? Validators.maxLength(this.maxlength) : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.updateValidators = function () {
        if (this.ngControl) {
            this.ngControl.control.setValidators(this.convertObjectToArray(this.validators));
            this.ngControl.control.updateValueAndValidity();
        }
    };
    /**
     * @param {?} validators
     * @return {?}
     */
    ThfInputBaseComponent.prototype.convertObjectToArray = function (validators) {
        var /** @type {?} */ validatorsArr = [];
        Object.keys(validators).forEach(function (key) {
            if (validators[key]) {
                validatorsArr.push(validators[key]);
            }
        });
        return validatorsArr;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeyup = function (e) {
        if (this.mask) {
            if (e.target.keyCode !== 229) {
                this.eventOnBlur(e);
                this.objMask.keyup(e);
            }
            this.callOnChange(this.objMask.valueToModel);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeypress = function (e) {
        this.objMask.keypress(e);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeydown = function (e) {
        if (this.mask) {
            if (e.target.keyCode !== 229) {
                this.eventOnBlur(e);
                this.objMask.keydown(e);
            }
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.hasInvalidClass = function () {
        return (this.el.nativeElement.classList.contains('ng-invalid') &&
            this.el.nativeElement.classList.contains('ng-dirty') &&
            this.inputEl.nativeElement.value !== '');
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.cleanInput = function () {
        var /** @type {?} */ hadValue = false;
        this.fireChange = false;
        // Se continha valor no campo, e o valor era diferente do ultimo evento change
        if (this.inputEl.nativeElement.value !== '') {
            hadValue = true;
        }
        this.inputEl.nativeElement.value = '';
        if (this.clean !== '') {
            this.callOnChange('');
        }
        if (hadValue) {
            // Emite onchange pois o valor mudou
            this.change.emit();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnInput = function (e) {
        if (this.mask) {
            return;
        }
        if (this.maxlength) {
            if (e.target.value.length > this.maxlength) {
                e.target.value = e.target.value.toString().substring(0, this.maxlength);
            }
        }
        this.callOnChange(e.target.value);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnFocus = function (e) {
        // Atualiza valor da variável que será usada para verificar se o campo teve alteração
        this.valueBeforeChange = this.inputEl.nativeElement.value;
        // Dispara evento quando o usuário entrar no campo
        // Este evento também é disparado quando o campo inicia com foco.
        this.enter.emit();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnBlur = function (e) {
        var _this = this;
        this.objMask.blur(e);
        this.blur.emit();
        // Emite o evento change manualmente quando o campo é alterado
        // Este evento é controlado manualmente devido ao preventDefault existente na máscara
        // e devido ao controle do t-clean, que também precisa emitir change
        if (this.inputEl.nativeElement.value !== this.valueBeforeChange) {
            this.fireChange = true;
            setTimeout(function () {
                if (_this.fireChange) {
                    _this.change.emit();
                }
            }, 200);
        }
    };
    /**
     * @param {?} pattern
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.verifyPattern = function (pattern, value) {
        var /** @type {?} */ regex = new RegExp(pattern);
        return regex.test(value);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnClick = function ($event) {
        // Atualiza a posição do cursor ao clicar
        if (this.mask) {
            this.objMask.click($event);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.writeValue = function (value) {
        if (this.inputEl) {
            if (value) {
                if (this.mask) {
                    this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
                    // Se o model for definido como formatado, então precisa atualizá-lo no primeiro acesso
                    if (this.objMask._formatModel) {
                        this.onChangePropagate(this.objMask.valueToModel);
                    }
                }
                else {
                    this.inputEl.nativeElement.value = value;
                }
            }
            else {
                this.inputEl.nativeElement.value = '';
            }
        }
        // Emite evento quando o model é atualizado, inclusive a primeira vez
        if (value) {
            this.change.emit();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.callOnChange = function (value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangePropagate) {
            if (this.type === 'number') {
                this.onChangePropagate(Number(value));
            }
            else {
                this.onChangePropagate(value);
            }
        }
        // Emite o event changeModel apenas se o model for diferente da última vez
        if (this.modelLastUpdate !== value) {
            this.changeModel.emit();
            this.modelLastUpdate = value;
        }
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfInputBaseComponent.prototype.registerOnChange = function (func) {
        this.onChangePropagate = func;
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfInputBaseComponent.prototype.registerOnTouched = function (func) {
        this.onTouched = func;
    };
    /**
     * @nocollapse
     */
    ThfInputBaseComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    ThfInputBaseComponent.propDecorators = {
        'setName': [{ type: Input, args: ['name',] },],
        'placeholder': [{ type: Input, args: ['t-placeholder',] },],
        'setDisabled': [{ type: Input, args: ['t-disabled',] },],
        'setReadonly': [{ type: Input, args: ['t-readonly',] },],
        'setRequired': [{ type: Input, args: ['t-required',] },],
        'setFocus': [{ type: Input, args: ['t-focus',] },],
        'setClean': [{ type: Input, args: ['t-clean',] },],
        'setPattern': [{ type: Input, args: ['t-pattern',] },],
        'errorPattern': [{ type: Input, args: ['t-error-pattern',] },],
        'setMaxlength': [{ type: Input, args: ['t-maxlength',] },],
        'setMinlength': [{ type: Input, args: ['t-minlength',] },],
        'setMask': [{ type: Input, args: ['t-mask',] },],
        'setMaskFormatModel': [{ type: Input, args: ['t-mask-format-model',] },],
        'blur': [{ type: Output, args: ['t-blur',] },],
        'enter': [{ type: Output, args: ['t-enter',] },],
        'change': [{ type: Output, args: ['t-change',] },],
        'changeModel': [{ type: Output, args: ['t-change-model',] },],
        'inputEl': [{ type: ViewChild, args: ['inp', { read: ElementRef },] },],
        'cleanEl': [{ type: ViewChild, args: ['clean', { read: ElementRef },] },],
        'onKeyup': [{ type: HostListener, args: ['keyup', ['$event'],] },],
        'onKeypress': [{ type: HostListener, args: ['keypress', ['$event'],] },],
        'onKeydown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    };
    return ThfInputBaseComponent;
}());
export { ThfInputBaseComponent };
function ThfInputBaseComponent_tsickle_Closure_declarations() {
    /**
     * @nocollapse
     * @type {?}
     */
    ThfInputBaseComponent.ctorParameters;
    /** @type {?} */
    ThfInputBaseComponent.propDecorators;
    /**
     * Nome e Id do Input
     * @type {?}
     */
    ThfInputBaseComponent.prototype.name;
    /**
     * Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido
     * @type {?}
     */
    ThfInputBaseComponent.prototype.placeholder;
    /**
     * Indica que o campo será desabilitado
     * @type {?}
     */
    ThfInputBaseComponent.prototype.disabled;
    /**
     * Indica que o campo será somente leitura
     * @type {?}
     */
    ThfInputBaseComponent.prototype.readonly;
    /**
     * Indica que o campo será obrigatório
     * @type {?}
     */
    ThfInputBaseComponent.prototype.required;
    /**
     * Indica que o campo iniciará com foco
     * @type {?}
     */
    ThfInputBaseComponent.prototype.focus;
    /**
     * Indica se o campo terá a opção de limpa-lo
     * Opções:
     *  "" : para limpar o campo e atribuir "" para o model
     *  "undefined" : para limpar o campo e atribuir undefined para o model
     *  qualquer valor : para atribuir este valor ao campo e ao model
     * @type {?}
     */
    ThfInputBaseComponent.prototype.clean;
    /**
     * Expressão regular para validar o campo.
     * Quando o campo possuir uma máscara (t-mask) será automaticamente validado por ela, porém
     * é possível definir um t-pattern para substituir a validação da máscara.
     * @type {?}
     */
    ThfInputBaseComponent.prototype.pattern;
    /**
     * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
     * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido
     * @type {?}
     */
    ThfInputBaseComponent.prototype.errorPattern;
    /**
     * Indica a quantidade máxima de caracteres que o campo aceita
     * @type {?}
     */
    ThfInputBaseComponent.prototype.maxlength;
    /**
     * Indica a quantidade mínima de caracteres que o campo aceita
     * @type {?}
     */
    ThfInputBaseComponent.prototype.minlength;
    /**
     * Indica máscara que o campo vai receber. Exemplo: (+99) (99) 99999?-9999
     * A máscara poderá ser validada por um pattern diferente da máscara informada, usando
     * a propriedade t-pattern.
     * O campo sendo obrigatório (t-required), será sinalizado quando estiver fora do padrão definido.
     * @type {?}
     */
    ThfInputBaseComponent.prototype.mask;
    /**
     * Indica se o model receberá o valor formatado ou puro. Padrão valor puro 'false'.
     * @type {?}
     */
    ThfInputBaseComponent.prototype.maskFormatModel;
    /**
     * Evento disparado ao sair do campo
     * @type {?}
     */
    ThfInputBaseComponent.prototype.blur;
    /**
     * Evento disparado ao entrar do campo
     * @type {?}
     */
    ThfInputBaseComponent.prototype.enter;
    /**
     * Evento disparado ao alterar valor e deixar o campo
     * @type {?}
     */
    ThfInputBaseComponent.prototype.change;
    /**
     * Evento disparado ao alterar valor do model
     * @type {?}
     */
    ThfInputBaseComponent.prototype.changeModel;
    /** @type {?} */
    ThfInputBaseComponent.prototype.inputEl;
    /** @type {?} */
    ThfInputBaseComponent.prototype.cleanEl;
    /** @type {?} */
    ThfInputBaseComponent.prototype.type;
    /** @type {?} */
    ThfInputBaseComponent.prototype.validators;
    /** @type {?} */
    ThfInputBaseComponent.prototype.ngControl;
    /** @type {?} */
    ThfInputBaseComponent.prototype.onChangePropagate;
    /** @type {?} */
    ThfInputBaseComponent.prototype.onTouched;
    /** @type {?} */
    ThfInputBaseComponent.prototype.el;
    /** @type {?} */
    ThfInputBaseComponent.prototype.objMask;
    /** @type {?} */
    ThfInputBaseComponent.prototype.valueBeforeChange;
    /** @type {?} */
    ThfInputBaseComponent.prototype.modelLastUpdate;
    /** @type {?} */
    ThfInputBaseComponent.prototype.fireChange;
}
