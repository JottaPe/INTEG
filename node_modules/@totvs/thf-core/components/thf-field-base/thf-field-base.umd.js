(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common/http')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/forms', '@angular/common/http'], factory) :
	(factory((global['thf-field-base'] = {}),global.core,global.forms,global.http));
}(this, (function (exports,core,forms,http) { 'use strict';

/**
 * @param {?} val
 * @return {?}
 */
function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    return !!val;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */

/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @return {?}
 */

/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */
function convertIsoToDate(value, start, end) {
    if (value) {
        var /** @type {?} */ day = parseInt(value.substring(8, 10), 10);
        var /** @type {?} */ month = parseInt(value.substring(5, 7), 10);
        var /** @type {?} */ year = parseInt(value.substring(0, 4), 10);
        if (start) {
            return new Date(year, month - 1, day, 0, 0, 0);
        }
        else if (end) {
            return new Date(year, month - 1, day, 23, 59, 59);
        }
        else {
            var /** @type {?} */ milliseconds = Date.parse(value);
            var /** @type {?} */ timezone = new Date().getTimezoneOffset() * 60000;
            return new Date(milliseconds + timezone);
        }
    }
}
/**
 * @param {?} value
 * @param {?} time
 * @return {?}
 */
function convertDateToISOExtended(value, time) {
    if (value) {
        var /** @type {?} */ day = value.getDate() < 10 ? '0' + value.getDate() : value.getDate();
        var /** @type {?} */ month = value.getMonth() + 1 < 10 ? '0' + (value.getMonth() + 1) : (value.getMonth() + 1);
        var /** @type {?} */ year = value.getFullYear();
        var /** @type {?} */ dateString = value.toString();
        if (time !== null) {
            return year + '-' + month + '-' + day + time;
        }
        else {
            return year + '-' + month + '-' + day + 'T' + dateString.substring(16, 24) +
                dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
        }
    }
    else {
        return null;
    }
}
/**
 * @return {?}
 */

/**
 * @return {?}
 */

/**
 * @param {?} value
 * @return {?}
 */

/**
 * \@description
 *
 * O componente thf-checkbox-group deve ser utilizado para disponibilizar múltiplas
 * opções ao usuário, permitindo a ele que selecione uma ou múltiplas delas.
 */
var ThfCheckboxGroupBaseComponent = (function () {
    /**
     * @param {?} el
     * @param {?=} ngControl
     */
    function ThfCheckboxGroupBaseComponent(el, ngControl) {
        /**
         * Indica que o campo será obrigatório
         */
        this.required = false;
        /**
         * Lista de opções que serão exibidas
         * Nesta propriedade deve ser definido um array de objetos que implementam a interface ThfCheckboxGroupOption
         */
        this.options = [];
        /**
         * Evento ao alterar valor do campo
         */
        this.change = new core.EventEmitter;
        this.el = el;
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfCheckboxGroupBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = (required === '') ? true : convertToBoolean(required);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.ngOnInit = function () {
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            if (this.required) {
                this.ngControl.control.setValidators([forms.Validators.required]);
            }
        }
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.eventClick = function (name, value) {
        var /** @type {?} */ index;
        var /** @type {?} */ selected = this.inputEl.nativeElement.querySelector(".thf-input-checkbox[id=\"" + (name + value) + "\"]");
        if (selected) {
            if (selected.checked && !this.selectCheckedValue.includes(value)) {
                this.selectCheckedValue.push(value);
            }
            else if (!selected.checked && this.selectCheckedValue.includes(value)) {
                index = this.selectCheckedValue.indexOf(value);
                this.selectCheckedValue.splice(index, 1);
            }
            this.changeValue(this.selectCheckedValue);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.changeValue = function (value) {
        this.propagateChange(value);
        this.change.emit(value);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.writeValue = function (value) {
        if (value) {
            this.changeValue(value);
            this.selectCheckedValue = [].concat(value);
        }
        var /** @type {?} */ selected = this.inputEl.nativeElement.querySelectorAll(".thf-input-checkbox");
        if (selected && value) {
            for (var /** @type {?} */ i = 0; i < selected.length; i++) {
                if (value.includes(selected[i].value)) {
                    selected[i].checked = true;
                }
                else {
                    selected[i].checked = false;
                }
            }
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @return {?}
     */
    ThfCheckboxGroupBaseComponent.prototype.registerOnTouched = function () { };
    /**
     * @nocollapse
     */
    ThfCheckboxGroupBaseComponent.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfCheckboxGroupBaseComponent.propDecorators = {
        'name': [{ type: core.Input, args: ['name',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'options': [{ type: core.Input, args: ['t-options',] },],
        'change': [{ type: core.Output, args: ['t-change',] },],
        'inputEl': [{ type: core.ViewChild, args: ['inp', { read: core.ElementRef },] },],
    };
    return ThfCheckboxGroupBaseComponent;
}());

/**
 * \@description
 *
 * O thf-datepicker é um componente específico para manipulação de datas permitindo a digitação e / ou seleção.
 *
 * O formato de exibição da data, ou seja, o formato que é apresentado ao usuário é o dd/mm/yyyy,
 * mas podem ser definidos outros padrões (veja mais na propriedade t-format).
 *
 * O idioma padrão do calendário será exibido de acordo com o navegador, caso tenha necessidade de alterar
 * use a propriedade t-locale.
 *
 * O datepicker aceita apenas dois formatos de data o ISO-8601 extendido e o Date padrão do Javascript.
 * Exemplo:
 *
 * ```
 * this.date = '2017-11-28T00:00:00-02:00'
 * this.date = new Date(2017, 10, 28);
 * ```
 *
 * > O thf-datepicker usa o padrão ISO-8601 extendido internamente, ou seja, o model estará nesse padrão.
 *
 * Importante:
 *
 * - Caso a data seja inválida, o model receberá: 'Data inválida'.
 * - Caso a data esteja fora do período estabelecido pelas propriedades t-start e t-end,
 * então o model receberá: 'Data fora do período'
 * - Caso o input não esteja dentro de um form, é preciso adicionar ngDefaultControl ao componente:
 * Exemplo:
 *
 * ```
 * <thf-datepicker
 *   name="pessoa.nome"
 *   [(ngModel)]="pessoa.nome"
 *   ngDefaultControl>
 * </thf-datepicker>
 * ```
 *
 * - Caso o input esteja passando um [(ngModel)], mas não tenha um name, então irá ocorrer um erro
 * do próprio angular.
 * [ngModelOptions]="{standalone: true}".
 * Exemplo:
 *
 * ```
 * <thf-datepicker
 *   [(ngModel)]="pessoa.nome"
 *   [ngModelOptions]="{standalone: true}"
 * </thf-datepicker>
 * ```
 *
 * - Não esqueça de importar o FormsModule no seu módulo, assim como também é importado para
 * utilizar o input padrão.
 * @abstract
 */
var ThfDatepickerBaseComponent = (function () {
    /**
     * @param {?=} ngControl
     */
    function ThfDatepickerBaseComponent(ngControl) {
        /**
         * Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido.
         */
        this.placeholder = '';
        /**
         * Indica que o campo será desabilitado.
         */
        this.disabled = false;
        /**
         * Indica que o campo será somente leitura.
         */
        this.readonly = false;
        /**
         * Indica que o campo será obrigatório.
         */
        this.required = false;
        /**
         * Indica que o campo iniciará com foco.
         */
        this.focus = false;
        /**
         * Indica se o campo terá a opção de limpá-lo.
         */
        this.clean = false;
        /**
         * Mensagem que será apresentada quando o pattern ou a máscara não for satisfatória.
         * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
         */
        this.errorPattern = '';
        /**
         * Idioma do Datepicker. Opções: pt, en, es.
         * Por padrão será usado o idioma do browser.
         */
        this.locale = navigator.language;
        /**
         * Evento disparado ao sair do campo.
         */
        this.onblur = new core.EventEmitter();
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.onchange = new core.EventEmitter();
        this.onChangeModel = null;
        this.onTouchedModel = null;
        this.validators = [];
        this.firstStart = true;
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDisabled", {
        /**
         * @param {?} disabled
         * @return {?}
         */
        set: function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setReadonly", {
        /**
         * @param {?} readonly
         * @return {?}
         */
        set: function (readonly) {
            this.readonly = readonly === '' ? true : convertToBoolean(readonly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            var _this = this;
            this.required = required === '' ? true : convertToBoolean(required);
            setTimeout(function () {
                if (_this.required) {
                    _this.controlModel(_this.date);
                }
                else {
                    if (_this.date) {
                        _this.controlModel(_this.date);
                    }
                    else {
                        _this.onChangeModel('');
                    }
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setFocus", {
        /**
         * @param {?} focus
         * @return {?}
         */
        set: function (focus) {
            this.focus = focus === '' ? true : convertToBoolean(focus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setClean", {
        /**
         * @param {?} clean
         * @return {?}
         */
        set: function (clean) {
            this.clean = clean === '' ? true : convertToBoolean(clean);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDateStart", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            var _this = this;
            if (value instanceof Date) {
                this.start = new Date(value.getFullYear(), value.getMonth(), value.getDate(), 0, 0, 0);
            }
            else {
                this.start = convertIsoToDate(value, true, false);
            }
            setTimeout(function () {
                if (_this.date) {
                    _this.controlModel(_this.date);
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setDateEnd", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            var _this = this;
            if (value instanceof Date) {
                this.end = new Date(value.getFullYear(), value.getMonth(), value.getDate(), 23, 59, 59);
            }
            else {
                this.end = convertIsoToDate(value, false, true);
            }
            setTimeout(function () {
                if (_this.date) {
                    _this.controlModel(_this.date);
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setFormat", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            value = value.toLowerCase();
            if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
                this.format = value;
            }
            else {
                this.format = this.locale.indexOf('en') > -1 ? 'mm/dd/yyyy' : 'dd/mm/yyyy';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfDatepickerBaseComponent.prototype, "setLocale", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this.locale = value.length < 2 ? 'en' : value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @abstract
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.cleanInput = function () { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.writeValue = function (value) { };
    /**
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.ngOnInit = function () {
        if (!this.format) {
            this.format = (this.locale.indexOf('en') > -1) ? 'mm/dd/yyyy' : 'dd/mm/yyyy';
        }
        // Classe de máscara
        this.objMask = this.buildMask();
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            // Validações do campo. Estas validações que irão tornar o campo válido ou inválido
            if (this.required) {
                this.validators.push(forms.Validators.required);
            }
            this.validators.push(this.validate);
            this.ngControl.control.setValidators(this.validators);
        }
    };
    /**
     * @param {?} dateString
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.getDateFromString = function (dateString) {
        var /** @type {?} */ day = parseInt(dateString.substring(this.format.indexOf('d'), this.format.indexOf('d') + 2), 10);
        var /** @type {?} */ month = parseInt(dateString.substring(this.format.indexOf('m'), this.format.indexOf('m') + 2), 10) - 1;
        var /** @type {?} */ year = parseInt(dateString.substring(this.format.indexOf('y'), this.format.indexOf('y') + 4), 10);
        var /** @type {?} */ date = new Date(year, month, day);
        return (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) ? date : null;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.formatToDate = function (value) {
        var /** @type {?} */ dateFormatted = this.format;
        dateFormatted = dateFormatted.replace('dd', ('0' + value.getDate()).slice(-2));
        dateFormatted = dateFormatted.replace('mm', ('0' + (value.getMonth() + 1)).slice(-2));
        dateFormatted = dateFormatted.replace('yyyy', String(value.getFullYear()));
        return dateFormatted;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.controlModel = function (date) {
        if (date) {
            if (this.start && this.end) {
                this.validateModel((date >= this.start && date <= this.end), date);
            }
            if (this.start && !this.end) {
                this.validateModel((date >= this.start), date);
            }
            if (this.end && !this.start) {
                this.validateModel((date <= this.end), date);
            }
            if (!this.start && !this.end) {
                this.date = date;
                this.callOnChange(convertDateToISOExtended(this.date, this.hour));
            }
        }
        else {
            this.date = date;
            if (this.required) {
                this.callOnChange('Data Inválida');
            }
            else {
                this.callOnChange('');
            }
        }
    };
    /**
     * @param {?} dateValid
     * @param {?} date
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validateModel = function (dateValid, date) {
        if (dateValid) {
            this.date = date;
            this.callOnChange(convertDateToISOExtended(this.date, this.hour));
        }
        else {
            this.date = date;
            this.callOnChange('Data fora do período');
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.callOnChange = function (value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(value);
        }
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnChange = function (func) {
        this.onChangeModel = func;
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.registerOnTouched = function (func) {
        this.onTouchedModel = func;
    };
    /**
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.buildMask = function () {
        var /** @type {?} */ mask = this.format.toUpperCase();
        mask = mask.replace(/DD/g, '99');
        mask = mask.replace(/MM/g, '99');
        mask = mask.replace(/YYYY/g, '9999');
        return new ThfMask(mask, true);
    };
    /**
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.cleanModel = function () {
        this.callOnChange('');
        this.cleanInput();
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ThfDatepickerBaseComponent.prototype.validate = function (control) {
        if (control.value && isNaN(Date.parse(control.value))) {
            return { invalidDate: true };
        }
        else {
            return null;
        }
    };
    /**
     * @nocollapse
     */
    ThfDatepickerBaseComponent.ctorParameters = function () { return [
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfDatepickerBaseComponent.propDecorators = {
        'name': [{ type: core.Input, args: ['name',] },],
        'placeholder': [{ type: core.Input, args: ['t-placeholder',] },],
        'setDisabled': [{ type: core.Input, args: ['t-disabled',] },],
        'setReadonly': [{ type: core.Input, args: ['t-readonly',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'setFocus': [{ type: core.Input, args: ['t-focus',] },],
        'setClean': [{ type: core.Input, args: ['t-clean',] },],
        'errorPattern': [{ type: core.Input, args: ['t-error-pattern',] },],
        'setDateStart': [{ type: core.Input, args: ['t-start',] },],
        'setDateEnd': [{ type: core.Input, args: ['t-end',] },],
        'setFormat': [{ type: core.Input, args: ['t-format',] },],
        'setLocale': [{ type: core.Input, args: ['t-locale',] },],
        'onblur': [{ type: core.Output, args: ['t-blur',] },],
        'onchange': [{ type: core.Output, args: ['t-change',] },],
    };
    return ThfDatepickerBaseComponent;
}());

/**
 * Para usar o thf-mask é preciso instanciar esta classe passando a máscara como
 * primeiro parâmetro, e no segundo parâmetro, deve se informado true, caso queira
 * que o model seja formatado ou false para o que o model seja limpo.
 */
var ThfMask = (function () {
    /**
     * @param {?} mask
     * @param {?} formatModel
     */
    function ThfMask(mask, formatModel) {
        this.mask = '';
        this.formatModel = false;
        // controle de posição
        this.initialPosition = 0;
        this.finalPosition = 0;
        this.pattern = '';
        this.keypress = function ($event) { };
        this.mask = mask;
        this.formatModel = formatModel;
        this.pattern = this.getRegexFromMask(mask);
    }
    Object.defineProperty(ThfMask.prototype, "getPattern", {
        /**
         * @return {?}
         */
        get: function () {
            return this.pattern;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "getValueToInput", {
        /**
         * @return {?}
         */
        get: function () {
            return this.valueToInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "setValueToInput", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this.valueToInput = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "getValueToModel", {
        /**
         * @return {?}
         */
        get: function () {
            return this.valueToModel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfMask.prototype, "setValueToModel", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this.valueToModel = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.keyup = function ($event) {
        if (this.mask) {
            var /** @type {?} */ value = $event.target.value;
            // formata o valor quando for colado com control + v e reposiciona o cursor
            if ($event.keyCode === 17 || $event.keyCode === 91) {
                $event.target.value = this.controlFormatting(value);
                this.resetPositions($event);
            }
            $event.preventDefault();
            switch ($event.keyCode) {
                case 37:// seta esquerda
                    if (this.initialPosition > 0) {
                        this.initialPosition--;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 39:// seta direita
                    if (this.initialPosition < value.toString().length) {
                        this.initialPosition++;
                    }
                    this.setPositionNotShiftKey($event);
                    this.setSelectionRange($event);
                    break;
                case 35:// end
                    this.finalPosition = value.toString().length;
                    if ($event.shiftKey) {
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = this.finalPosition;
                        this.setPositions($event);
                    }
                    break;
                case 36:// HOME
                    if ($event.shiftKey) {
                        this.finalPosition = this.initialPosition;
                        this.initialPosition = 0;
                        this.setPositions($event);
                    }
                    else {
                        this.initialPosition = 0;
                        this.finalPosition = 0;
                        this.setPositions($event);
                    }
                    break;
            }
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setPositionNotShiftKey = function ($event) {
        if (!$event.shiftKey) {
            this.finalPosition = this.initialPosition;
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setSelectionRange = function ($event) {
        if (this.initialPosition > this.finalPosition) {
            $event.target.setSelectionRange(this.finalPosition, this.initialPosition);
        }
        else {
            $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.keydown = function ($event) {
        if (this.mask) {
            var /** @type {?} */ value = $event.target.value;
            if ($event.keyCode === 9) {
                return;
            }
            if (!$event.ctrlKey && !$event.metaKey) {
                $event.preventDefault();
            }
            // Não faz nada quando for digitado CTRL ou COMMAND e V
            // Já está sendo tratado no evento keyup
            if ($event.ctrlKey || $event.metaKey && ($event.keyCode !== 86) ||
                ($event.keyCode >= 37 && $event.keyCode <= 40) || $event.keyCode === 16 || $event.keyCode === 9) {
                return;
            }
            // Valida a tecla digitada
            if (this.isKeyValid($event.keyCode)) {
                if (this.finalPosition === null) {
                    this.finalPosition = this.initialPosition;
                }
                this.revertPositions(this.initialPosition, this.finalPosition);
                switch ($event.keyCode) {
                    case 8:// backspace
                        this.getPosition($event);
                        if (this.initialPosition < 0) {
                            this.initialPosition = 0;
                            this.setPositions($event);
                        }
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskBefore($event, -1);
                            if (this.initialPosition !== 0) {
                                value = value.slice(0, this.initialPosition - 1) + value.slice(this.finalPosition);
                                value = this.controlFormatting(value);
                                $event.target.value = value;
                                this.changePosition($event, -1);
                                this.checkMaskBefore($event, -1);
                                this.setPositions($event);
                                this.resetPositions($event);
                            }
                        }
                        else {
                            this.clearRangeSelection(value, $event, true);
                        }
                        this.setPositions($event);
                        break;
                    case 46:// delete
                        this.getPosition($event);
                        if (this.initialPosition === this.finalPosition) {
                            this.checkMaskAfter($event, 1);
                            value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition + 1);
                            value = this.controlFormatting(value);
                            $event.target.value = value;
                            this.setPositions($event);
                            this.resetPositions($event);
                        }
                        else {
                            this.clearRangeSelection(value, $event, false);
                        }
                        this.setPositions($event);
                        break;
                    default:// qualquer outra tecla válida
                        value = value.slice(0, this.initialPosition) + $event.key + value.slice(this.finalPosition);
                        value = this.controlFormatting(value);
                        $event.target.value = value;
                        this.changePosition($event, 1);
                        this.checkMaskBefore($event, 1);
                        this.setPositions($event);
                        this.resetPositions($event);
                        this.setPositions($event);
                }
            }
        }
    };
    /**
     * @param {?} value
     * @param {?} $event
     * @param {?} isBackspace
     * @return {?}
     */
    ThfMask.prototype.clearRangeSelection = function (value, $event, isBackspace) {
        value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition);
        value = this.controlFormatting(value);
        $event.target.value = value;
        if (isBackspace) {
            this.checkMaskBefore($event, -1);
        }
        this.setPositions($event);
        this.resetPositions($event);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.click = function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.blur = function ($event) {
        // Se houver algum valor definido na máscara
        if (this.mask) {
            // pega o valor do campo, formata e passa para o model
            var /** @type {?} */ value = $event.target.value;
            value = this.controlFormatting(value);
            $event.target.value = value;
        }
    };
    /**
     * @param {?} initialPosition
     * @param {?} finalPosition
     * @return {?}
     */
    ThfMask.prototype.revertPositions = function (initialPosition, finalPosition) {
        if (initialPosition > finalPosition) {
            // inverte o controle de posição caso o inicial esteja maior que o final
            var /** @type {?} */ tempPosition = void 0;
            tempPosition = initialPosition;
            this.initialPosition = finalPosition;
            this.finalPosition = tempPosition;
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.resetPositions = function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = this.initialPosition;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.setPositions = function ($event) {
        $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
    };
    /**
     * @param {?} $event
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.changePosition = function ($event, value) {
        this.initialPosition = this.initialPosition + value;
        this.finalPosition = this.finalPosition + value;
        this.setPositions($event);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfMask.prototype.getPosition = function ($event) {
        this.initialPosition = $event.target.selectionStart;
        this.finalPosition = $event.target.selectionEnd;
        this.setPositions($event);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.controlFormatting = function (value) {
        // Se o valor for vazio, retorna vazio
        if (!value) {
            this.valueToInput = '';
            this.valueToModel = '';
            return '';
        }
        var /** @type {?} */ valueProcessed;
        var /** @type {?} */ maskTmp = this.mask;
        // Array que será usado para armazenar todas as máscaras possíveis para
        // quando houver um valor opcional (?)
        var /** @type {?} */ arrMasks = [];
        var /** @type {?} */ contMasks = 0;
        // Enquanto houver algum 9? na máscara
        while (this.hasOptionalNumber(maskTmp)) {
            arrMasks.push(maskTmp);
            maskTmp = this.replaceOptionalNumber(maskTmp);
        }
        arrMasks.push(maskTmp);
        // Inverte o array
        arrMasks.reverse();
        // Informa que a formatação ainda não chegou ao fim
        this.formattingEnds = false;
        while (!this.formattingEnds) {
            // Seta a formatação como terminada
            // Então o método formatValue irá setar como não terminado caso haja
            this.formattingEnds = true;
            // Se não existe mais nenhuma máscara possível, então encerra a formatação
            if (!arrMasks[contMasks]) {
                break;
            }
            // Chama a formatação passando a máscara e o valor
            valueProcessed = this.formatValue(value, arrMasks[contMasks]);
            contMasks++;
        }
        return valueProcessed;
    };
    /**
     * @param {?} value
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.formatValue = function (value, mask) {
        // Remove as marcas de valor opciona (?)
        mask = mask.replace(/\?/g, '');
        // Substitui todos os caracteres que não são fixos da máscara por _
        var /** @type {?} */ guide = mask.replace(this.listValidKeys(), '_');
        // Contador usado para percorrer o guide
        var /** @type {?} */ contGuide = 0;
        // String final formatada
        var /** @type {?} */ valueProcessed = '';
        // Remove do valor todos os caracteres fixos como ()/-+
        value = this.removeFormattingValue(value);
        // Percorre todo o valor e coloca a formatação de acordo com a máscara
        for (var /** @type {?} */ i = 0; i < value.length; i++) {
            var /** @type {?} */ charValue = value[i];
            // Se o guide acabou, seta a formatação como não terminada para que o método controlFormatting
            // tente formatar com outra possível máscara
            if (!guide[contGuide]) {
                this.formattingEnds = false;
                break;
            }
            // Percorre o Guide enquanto tem caracteres fixos
            while (this.isFixedCharacterGuide(guide[contGuide]) && guide[contGuide]) {
                valueProcessed += guide[contGuide];
                contGuide++;
            }
            // É um caracter válido de acordo com a máscara
            if (this.isKeyValidMask(charValue, mask[contGuide])) {
                valueProcessed += charValue;
                contGuide++;
            }
            else {
                // Se não é um caracter válido, deve interromper.
                break;
            }
        }
        if (this.formatModel) {
            this.valueToInput = valueProcessed;
            this.valueToModel = valueProcessed;
        }
        else {
            this.valueToInput = valueProcessed;
            this.valueToModel = this.removeFormattingValue(valueProcessed);
        }
        return valueProcessed;
    };
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    ThfMask.prototype.checkMaskBefore = function ($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition - 1))) {
            this.changePosition($event, position);
            this.checkMaskBefore($event, position);
        }
    };
    /**
     * @param {?} $event
     * @param {?} position
     * @return {?}
     */
    ThfMask.prototype.checkMaskAfter = function ($event, position) {
        if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition))) {
            this.changePosition($event, position);
            this.checkMaskAfter($event, position);
        }
    };
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.replaceOptionalNumber = function (mask) {
        var /** @type {?} */ i = 9;
        while (i >= 0) {
            if (mask.indexOf(i + '?') > -1) {
                return mask.replace(i + '?', '');
            }
            i--;
        }
        return mask;
    };
    /**
     * @param {?} key
     * @return {?}
     */
    ThfMask.prototype.isFixedCharacterGuide = function (key) {
        return this.testRegex(key, this.getFixedCharacterGuide());
    };
    /**
     * @return {?}
     */
    ThfMask.prototype.getFixedCharacterGuide = function () {
        return /[\\\/() +-.\:]/g;
    };
    /**
     * @return {?}
     */
    ThfMask.prototype.listValidKeys = function () {
        return /[a-zA-Z0-9]/g;
    };
    /**
     * @param {?} keyCode
     * @return {?}
     */
    ThfMask.prototype.isKeyValid = function (keyCode) {
        return this.isKeyCodeValid(keyCode);
    };
    /**
     * @param {?} keyCode
     * @return {?}
     */
    ThfMask.prototype.isKeyCodeValid = function (keyCode) {
        return ((keyCode >= 48 && keyCode <= 57) ||
            (keyCode >= 65 && keyCode <= 90) ||
            (keyCode >= 96 && keyCode <= 105) ||
            (keyCode === 8) || keyCode === 9 ||
            (keyCode === 46));
    };
    /**
     * @param {?} key
     * @param {?} keyMask
     * @return {?}
     */
    ThfMask.prototype.isKeyValidMask = function (key, keyMask) {
        return this.testRegex(key, this.replaceMask(keyMask));
    };
    /**
     * @param {?} key
     * @param {?} regex
     * @return {?}
     */
    ThfMask.prototype.testRegex = function (key, regex) {
        return regex.test(key);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfMask.prototype.removeFormattingValue = function (value) {
        return value.replace(this.getFixedCharacterGuide(), '');
    };
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.hasOptionalNumber = function (mask) {
        return mask.match(/\d\?/g);
    };
    /**
     * @param {?} char
     * @return {?}
     */
    ThfMask.prototype.replaceMask = function (char) {
        var /** @type {?} */ regex = /./;
        switch (char) {
            case '0':
                regex = /[0]/;
                break;
            case '1':
                regex = /[0-1]/;
                break;
            case '2':
                regex = /[0-2]/;
                break;
            case '3':
                regex = /[0-3]/;
                break;
            case '4':
                regex = /[0-4]/;
                break;
            case '5':
                regex = /[0-5]/;
                break;
            case '6':
                regex = /[0-6]/;
                break;
            case '7':
                regex = /[0-7]/;
                break;
            case '8':
                regex = /[0-8]/;
                break;
            case '9':
                regex = /[0-9]/;
                break;
            case ' ':
                regex = /\s/;
                break;
            case '@':
                regex = /[a-zA-Z]/;
                break;
            case 'w':
                regex = /[a-zA-Z0-9]/;
                break;
        }
        return regex;
    };
    /**
     * @param {?} mask
     * @return {?}
     */
    ThfMask.prototype.getRegexFromMask = function (mask) {
        var /** @type {?} */ pattern;
        if (this.formatModel) {
            pattern = mask.replace(/\\/g, '\\\\');
            pattern = pattern.replace(/\+/g, '\\+');
            pattern = pattern.replace(/\./g, '\\.');
            pattern = pattern.replace(/-/g, '-');
            pattern = pattern.replace(/\(/g, '\\(');
            pattern = pattern.replace(/\)/g, '\\)');
            pattern = pattern.replace(/\//g, '\\/');
            pattern = pattern.replace(/\s/g, '\\s');
            pattern = pattern.replace(/:/g, '\\:');
            pattern = pattern.replace(/\@(?!\s)/g, '\\w');
            pattern = pattern.replace(/\d/g, '\\w');
        }
        else {
            pattern = mask.replace(/\\/g, '');
            pattern = pattern.replace(/\+/g, '');
            pattern = pattern.replace(/\./g, '');
            pattern = pattern.replace(/-/g, '');
            pattern = pattern.replace(/\(/g, '');
            pattern = pattern.replace(/\)/g, '');
            pattern = pattern.replace(/\//g, '');
            pattern = pattern.replace(/\s/g, '');
            pattern = pattern.replace(/:/g, '');
            pattern = pattern.replace(/\@/g, '\\w');
            pattern = pattern.replace(/\d/g, '\\w');
        }
        return pattern;
    };
    return ThfMask;
}());

/**
 * \@description
 *
 * Este é um componente baseado em input, com várias propriedades do input padrão e várias outras
 * propriedades extras como: máscara, pattern, mensagem de erro e etc.
 * Você deve informar a variável que contém o valor como [(ngModel)]="variavel", para que o
 * input receba o valor da variável e para que ela receba as alterações do valor (two-way-databinding).
 * A propriedade name é obrigatória para que o formulário e o model funcionem corretamente.
 *
 * Importante:
 * - Caso o input não esteja dentro de um form, é preciso adicionar ngDefaultControl ao componente:
 * Exemplo: [(ngModel)]="pessoa.nome" name="nome" ngDefaultControl
 *
 * - Caso o input esteja passando um [(ngModel)], mas não tenha um name, então irá ocorrer um erro
 * de angular. Então você precisa informar o atributo name ou o seguinte atributo
 * [ngModelOptions]="{standalone: true}".
 * Exemplo: [(ngModel)]="pessoa.nome" [ngModelOptions]="{standalone: true}"
 */
var ThfInputBaseComponent = (function () {
    /**
     * @param {?} el
     * @param {?=} ngControl
     */
    function ThfInputBaseComponent(el, ngControl) {
        /**
         * Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido
         */
        this.placeholder = '';
        /**
         * Indica que o campo será desabilitado
         */
        this.disabled = false;
        /**
         * Indica que o campo será somente leitura
         */
        this.readonly = false;
        /**
         * Indica que o campo será obrigatório
         */
        this.required = false;
        /**
         * Indica que o campo iniciará com foco
         */
        this.focus = false;
        /**
         * Indica se o campo terá a opção de limpa-lo
         * Opções:
         *  "" : para limpar o campo e atribuir "" para o model
         *  "undefined" : para limpar o campo e atribuir undefined para o model
         *  qualquer valor : para atribuir este valor ao campo e ao model
         */
        this.clean = '';
        /**
         * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
         * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido
         */
        this.errorPattern = '';
        /**
         * Indica máscara que o campo vai receber. Exemplo: (+99) (99) 99999?-9999
         * A máscara poderá ser validada por um pattern diferente da máscara informada, usando
         * a propriedade t-pattern.
         * O campo sendo obrigatório (t-required), será sinalizado quando estiver fora do padrão definido.
         */
        this.mask = '';
        /**
         * Indica se o model receberá o valor formatado ou puro. Padrão valor puro 'false'.
         */
        this.maskFormatModel = false;
        /**
         * Evento disparado ao sair do campo
         */
        this.blur = new core.EventEmitter();
        /**
         * Evento disparado ao entrar do campo
         */
        this.enter = new core.EventEmitter();
        /**
         * Evento disparado ao alterar valor e deixar o campo
         */
        this.change = new core.EventEmitter();
        /**
         * Evento disparado ao alterar valor do model
         */
        this.changeModel = new core.EventEmitter();
        this.type = 'text';
        this.validators = {};
        this.onChangePropagate = null;
        this.onTouched = null;
        this.fireChange = false;
        this.el = el;
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfInputBaseComponent.prototype, "setName", {
        /**
         * @param {?} name
         * @return {?}
         */
        set: function (name) {
            this.name = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setDisabled", {
        /**
         * @param {?} disabled
         * @return {?}
         */
        set: function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
            // Atualiza Validador do campo
            this.validators['required'] = this.getValidatorRequired();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setReadonly", {
        /**
         * @param {?} readonly
         * @return {?}
         */
        set: function (readonly) {
            this.readonly = readonly === '' ? true : convertToBoolean(readonly);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
            // Atualiza Validador do campo
            this.validators['required'] = this.getValidatorRequired();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setFocus", {
        /**
         * @param {?} focus
         * @return {?}
         */
        set: function (focus) {
            this.focus = focus === '' ? true : convertToBoolean(focus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setClean", {
        /**
         * @param {?} clean
         * @return {?}
         */
        set: function (clean) {
            this.clean = 'null';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setPattern", {
        /**
         * @param {?} pattern
         * @return {?}
         */
        set: function (pattern) {
            this.pattern = pattern;
            // Atualiza Validador do campo
            this.validators['pattern'] = this.getValidatorPattern();
            this.updateValidators();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMaxlength", {
        /**
         * @param {?} maxlength
         * @return {?}
         */
        set: function (maxlength) {
            if (!isNaN(parseInt(maxlength, 10))) {
                this.maxlength = parseInt(maxlength, 10);
                // Atualiza Validador do campo
                this.validators['maxlength'] = this.getValidatorMaxlength();
                this.updateValidators();
            }
            else if (maxlength === undefined) {
                this.maxlength = undefined;
                // Atualiza Validador do campo
                this.validators['maxlength'] = this.getValidatorMaxlength();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMinlength", {
        /**
         * @param {?} minlength
         * @return {?}
         */
        set: function (minlength) {
            if (!isNaN(parseInt(minlength, 10))) {
                this.minlength = parseInt(minlength, 10);
                // Atualiza Validador do campo
                this.validators['minlength'] = this.getValidatorMinlength();
                this.updateValidators();
            }
            else if (minlength === undefined) {
                this.minlength = undefined;
                // Atualiza Validador do campo
                this.validators['minlength'] = this.getValidatorMinlength();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMask", {
        /**
         * @param {?} mask
         * @return {?}
         */
        set: function (mask) {
            this.mask = mask;
            if (this.objMask instanceof ThfMask) {
                // Atualiza Máscara do Campo
                this.objMask = new ThfMask(this.mask, this.maskFormatModel);
                // Atualiza Validador do campo
                this.validators['pattern'] = this.getValidatorPattern();
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfInputBaseComponent.prototype, "setMaskFormatModel", {
        /**
         * @param {?} maskFormatModel
         * @return {?}
         */
        set: function (maskFormatModel) {
            this.maskFormatModel = maskFormatModel === '' ? true : convertToBoolean(maskFormatModel);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.ngOnInit = function () {
        this._onInit();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.ngAfterViewInit = function () {
        this._afterViewInit();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype._onInit = function () {
        // Classe de máscara
        this.objMask = new ThfMask(this.mask, this.maskFormatModel);
        this.setValidators();
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype._afterViewInit = function () {
        // Põe o foco no Input, setado pelo t-focus
        if (this.focus) {
            this.inputEl.nativeElement.focus();
        }
        if (this.clean) {
            this.inputEl.nativeElement.style.paddingRight = '30px';
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.setValidators = function () {
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            // Validações do campo. Estas validações que irão tornar o campo e o formulário válidos ou inválidos
            this.validators = {};
            this.validators['required'] = this.getValidatorRequired();
            this.validators['pattern'] = this.getValidatorPattern();
            this.validators['minlength'] = this.getValidatorMinlength();
            this.validators['maxlength'] = this.getValidatorMaxlength();
            this.updateValidators();
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorRequired = function () {
        return (!this.disabled && this.required) ? forms.Validators.required : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorPattern = function () {
        if (this.pattern) {
            return forms.Validators.pattern(this.pattern);
        }
        else if (this.mask) {
            var /** @type {?} */ patternToMask = this.objMask.getRegexFromMask(this.mask);
            return forms.Validators.pattern(patternToMask);
        }
        return null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorMinlength = function () {
        return (this.minlength) ? forms.Validators.minLength(this.minlength) : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.getValidatorMaxlength = function () {
        return (this.maxlength) ? forms.Validators.maxLength(this.maxlength) : null;
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.updateValidators = function () {
        if (this.ngControl) {
            this.ngControl.control.setValidators(this.convertObjectToArray(this.validators));
            this.ngControl.control.updateValueAndValidity();
        }
    };
    /**
     * @param {?} validators
     * @return {?}
     */
    ThfInputBaseComponent.prototype.convertObjectToArray = function (validators) {
        var /** @type {?} */ validatorsArr = [];
        Object.keys(validators).forEach(function (key) {
            if (validators[key]) {
                validatorsArr.push(validators[key]);
            }
        });
        return validatorsArr;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeyup = function (e) {
        if (this.mask) {
            if (e.target.keyCode !== 229) {
                this.eventOnBlur(e);
                this.objMask.keyup(e);
            }
            this.callOnChange(this.objMask.valueToModel);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeypress = function (e) {
        this.objMask.keypress(e);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.onKeydown = function (e) {
        if (this.mask) {
            if (e.target.keyCode !== 229) {
                this.eventOnBlur(e);
                this.objMask.keydown(e);
            }
        }
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.hasInvalidClass = function () {
        return (this.el.nativeElement.classList.contains('ng-invalid') &&
            this.el.nativeElement.classList.contains('ng-dirty') &&
            this.inputEl.nativeElement.value !== '');
    };
    /**
     * @return {?}
     */
    ThfInputBaseComponent.prototype.cleanInput = function () {
        var /** @type {?} */ hadValue = false;
        this.fireChange = false;
        // Se continha valor no campo, e o valor era diferente do ultimo evento change
        if (this.inputEl.nativeElement.value !== '') {
            hadValue = true;
        }
        this.inputEl.nativeElement.value = '';
        if (this.clean !== '') {
            this.callOnChange('');
        }
        if (hadValue) {
            // Emite onchange pois o valor mudou
            this.change.emit();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnInput = function (e) {
        if (this.mask) {
            return;
        }
        if (this.maxlength) {
            if (e.target.value.length > this.maxlength) {
                e.target.value = e.target.value.toString().substring(0, this.maxlength);
            }
        }
        this.callOnChange(e.target.value);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnFocus = function (e) {
        // Atualiza valor da variável que será usada para verificar se o campo teve alteração
        this.valueBeforeChange = this.inputEl.nativeElement.value;
        // Dispara evento quando o usuário entrar no campo
        // Este evento também é disparado quando o campo inicia com foco.
        this.enter.emit();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnBlur = function (e) {
        var _this = this;
        this.objMask.blur(e);
        this.blur.emit();
        // Emite o evento change manualmente quando o campo é alterado
        // Este evento é controlado manualmente devido ao preventDefault existente na máscara
        // e devido ao controle do t-clean, que também precisa emitir change
        if (this.inputEl.nativeElement.value !== this.valueBeforeChange) {
            this.fireChange = true;
            setTimeout(function () {
                if (_this.fireChange) {
                    _this.change.emit();
                }
            }, 200);
        }
    };
    /**
     * @param {?} pattern
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.verifyPattern = function (pattern, value) {
        var /** @type {?} */ regex = new RegExp(pattern);
        return regex.test(value);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ThfInputBaseComponent.prototype.eventOnClick = function ($event) {
        // Atualiza a posição do cursor ao clicar
        if (this.mask) {
            this.objMask.click($event);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.writeValue = function (value) {
        if (this.inputEl) {
            if (value) {
                if (this.mask) {
                    this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
                    // Se o model for definido como formatado, então precisa atualizá-lo no primeiro acesso
                    if (this.objMask._formatModel) {
                        this.onChangePropagate(this.objMask.valueToModel);
                    }
                }
                else {
                    this.inputEl.nativeElement.value = value;
                }
            }
            else {
                this.inputEl.nativeElement.value = '';
            }
        }
        // Emite evento quando o model é atualizado, inclusive a primeira vez
        if (value) {
            this.change.emit();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfInputBaseComponent.prototype.callOnChange = function (value) {
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangePropagate) {
            if (this.type === 'number') {
                this.onChangePropagate(Number(value));
            }
            else {
                this.onChangePropagate(value);
            }
        }
        // Emite o event changeModel apenas se o model for diferente da última vez
        if (this.modelLastUpdate !== value) {
            this.changeModel.emit();
            this.modelLastUpdate = value;
        }
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfInputBaseComponent.prototype.registerOnChange = function (func) {
        this.onChangePropagate = func;
    };
    /**
     * @param {?} func
     * @return {?}
     */
    ThfInputBaseComponent.prototype.registerOnTouched = function (func) {
        this.onTouched = func;
    };
    /**
     * @nocollapse
     */
    ThfInputBaseComponent.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfInputBaseComponent.propDecorators = {
        'setName': [{ type: core.Input, args: ['name',] },],
        'placeholder': [{ type: core.Input, args: ['t-placeholder',] },],
        'setDisabled': [{ type: core.Input, args: ['t-disabled',] },],
        'setReadonly': [{ type: core.Input, args: ['t-readonly',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'setFocus': [{ type: core.Input, args: ['t-focus',] },],
        'setClean': [{ type: core.Input, args: ['t-clean',] },],
        'setPattern': [{ type: core.Input, args: ['t-pattern',] },],
        'errorPattern': [{ type: core.Input, args: ['t-error-pattern',] },],
        'setMaxlength': [{ type: core.Input, args: ['t-maxlength',] },],
        'setMinlength': [{ type: core.Input, args: ['t-minlength',] },],
        'setMask': [{ type: core.Input, args: ['t-mask',] },],
        'setMaskFormatModel': [{ type: core.Input, args: ['t-mask-format-model',] },],
        'blur': [{ type: core.Output, args: ['t-blur',] },],
        'enter': [{ type: core.Output, args: ['t-enter',] },],
        'change': [{ type: core.Output, args: ['t-change',] },],
        'changeModel': [{ type: core.Output, args: ['t-change-model',] },],
        'inputEl': [{ type: core.ViewChild, args: ['inp', { read: core.ElementRef },] },],
        'cleanEl': [{ type: core.ViewChild, args: ['clean', { read: core.ElementRef },] },],
        'onKeyup': [{ type: core.HostListener, args: ['keyup', ['$event'],] },],
        'onKeypress': [{ type: core.HostListener, args: ['keypress', ['$event'],] },],
        'onKeydown': [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
    };
    return ThfInputBaseComponent;
}());

/**
 * \@description
 *
 * O componente thf-radio-group deve ser utilizado para disponibilizar multiplas
 * opções ao usuário, permitindo a ele que selecione apenas uma delas.
 */
var ThfRadioGroupBaseComponent = (function () {
    /**
     * @param {?} el
     * @param {?=} ngControl
     */
    function ThfRadioGroupBaseComponent(el, ngControl) {
        /**
         * Indica que o campo será desabilitado
         */
        this.disabled = false;
        /**
         * Indica que o campo será obrigatório
         */
        this.required = false;
        /**
         * Evento ao alterar valor do campo
         */
        this.change = new core.EventEmitter;
        this.propagateChange = function () { };
        this.el = el;
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfRadioGroupBaseComponent.prototype, "setDisabled", {
        /**
         * @param {?} disabled
         * @return {?}
         */
        set: function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfRadioGroupBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.ngOnInit = function () {
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            if (this.required) {
                this.ngControl.control.setValidators([forms.Validators.required]);
            }
        }
    };
    /**
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.keyup = function () {
        var /** @type {?} */ selected = this.inputEl.nativeElement.querySelector("input:checked");
        if (selected) {
            this.changeValue(selected.value);
        }
    };
    /**
     * @param {?} value
     * @param {?} disabled
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.eventClick = function (value, disabled) {
        if (!disabled) {
            this.changeValue(value);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.changeValue = function (value) {
        if (this.selectCheckedValue !== value) {
            this.change.emit(value);
        }
        this.selectCheckedValue = value;
        this.propagateChange(this.selectCheckedValue);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.writeValue = function (value) {
        var /** @type {?} */ selected;
        if (value !== undefined) {
            // Busca radio com o valor especificado
            selected = this.inputEl.nativeElement.querySelector("input[value='" + value + "']");
        }
        if (selected) {
            selected.checked = true;
            this.selectCheckedValue = value;
        }
        else {
            // Se não encontrar nenhum select com o valor especificado no model
            // então desmarca todos os radios
            selected = this.inputEl.nativeElement.querySelector("input:checked");
            if (selected) {
                selected.checked = false;
                this.selectCheckedValue = null;
            }
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @return {?}
     */
    ThfRadioGroupBaseComponent.prototype.registerOnTouched = function () { };
    /**
     * @nocollapse
     */
    ThfRadioGroupBaseComponent.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfRadioGroupBaseComponent.propDecorators = {
        'name': [{ type: core.Input, args: ['name',] },],
        'setDisabled': [{ type: core.Input, args: ['t-disabled',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'options': [{ type: core.Input, args: ['t-options',] },],
        'change': [{ type: core.Output, args: ['t-change',] },],
        'inputEl': [{ type: core.ViewChild, args: ['inp', { read: core.ElementRef },] },],
    };
    return ThfRadioGroupBaseComponent;
}());

/**
 * \@description
 *
 * O componente thf-select exibe uma lista de valores e permite que o usuário selecione um desses valores.
 * Os valores listados podem ser fixos ou dinâmicos de acordo com a necessidade do desenvolvedor, dando mais flexibilidade ao componente.
 * O thf-select não permite que o usuário informe um valor diferente dos valores listados, isso garante a consistência da informação.
 *
 * > Quando utilizar o componente fora da tag Form, deve ser informado a diretiva ngDefaultControl.
 *
 * @abstract
 */
var ThfSelectBaseComponent = (function () {
    /**
     * @param {?} element
     * @param {?} changeDetector
     * @param {?=} ngControl
     */
    function ThfSelectBaseComponent(element, changeDetector, ngControl) {
        this.element = element;
        this.changeDetector = changeDetector;
        /**
         * Indica que o campo será desabilitado.
         */
        this.disabled = false;
        /**
         * Indica que o campo será obrigatório
         */
        this.required = false;
        /**
         * Deve ser informada uma função que será disparada quando houver alterações no ngModel.
         */
        this.change = new core.EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new core.EventEmitter();
        this.validators = [];
        this.element = element;
        this.ngControl = ngControl;
    }
    /**
     * @abstract
     * @param {?} selectOption
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.updateModel = function (selectOption) { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.writeValue = function (value) { };
    /**
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.ngOnInit = function () {
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            if (this.required) {
                this.validators.push(forms.Validators.required);
            }
            this.ngControl.control.setValidators(this.validators);
        }
    };
    /**
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.ngAfterViewChecked = function () {
        this.changeDetector.detectChanges();
    };
    /**
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.onChange = function () {
        this.change.emit(null);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfSelectBaseComponent.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    /**
     * @nocollapse
     */
    ThfSelectBaseComponent.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: core.ChangeDetectorRef, },
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfSelectBaseComponent.propDecorators = {
        'disabled': [{ type: core.Input, args: ['t-disabled',] },],
        'required': [{ type: core.Input, args: ['t-required',] },],
        'label': [{ type: core.Input, args: ['t-label',] },],
        'name': [{ type: core.Input, args: ['name',] },],
        'help': [{ type: core.Input, args: ['t-help',] },],
        'placeholder': [{ type: core.Input, args: ['t-placeholder',] },],
        'options': [{ type: core.Input, args: ['t-options',] },],
        'change': [{ type: core.Output, args: ['t-change',] },],
        'ngModelChange': [{ type: core.Output, args: ['ngModelChange',] },],
    };
    return ThfSelectBaseComponent;
}());

var ThfSwitchLabelPosition = {};
ThfSwitchLabelPosition.Right = 0;
ThfSwitchLabelPosition.Left = 1;
ThfSwitchLabelPosition[ThfSwitchLabelPosition.Right] = "Right";
ThfSwitchLabelPosition[ThfSwitchLabelPosition.Left] = "Left";

/**
 * \@description
 *
 * O componente thf-switch é um checkbox mais intuitivo, pois faz analogia a um interruptor.
 * Deve ser usado quando quer se passar a ideia de ligar / desligar um funcionalidade específica.
 *
 * O texto exibido pode ser alterado de acordo com o valor setado aumentando as possibilidades de uso do componente,
 * sendo assim é importante sempre informar textos que contextualizem seu uso facilitando a compreensão por parte dos usuários.
 *
 * > Quando utilizar o componente fora da tag Form, deve ser informado a diretiva ngDefaultControl.
 */
var ThfSwitchBaseComponent = (function () {
    /**
     * @param {?=} changeDetector
     * @param {?=} ngControl
     */
    function ThfSwitchBaseComponent(changeDetector, ngControl) {
        /**
         * Texto exibido quando o componente estiver com o valor setado em *true*, se não for especificado um valor,
         * será exibido o texto "true".
         *
         */
        this.labelOn = 'true';
        /**
         * Texto exibido quando o componente estiver com o valor setado em *false*, se não for especificado um valor,
         * será exibido o texto "false".
         *
         */
        this.labelOff = 'false';
        /**
         * Posição de exibição do valor do switch, caso não seja especificado um valor, será exibido a direita do switch.
         *
         */
        this.labelPosition = ThfSwitchLabelPosition.Right;
        /**
         * Indica se o campo será desabilitado.
         */
        this.disabled = false;
        /**
         * Indica se o campo será obrigatório.
         */
        this.required = false;
        /**
         * Evento disparado ao alterar valor do campo.
         */
        this.change = new core.EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new core.EventEmitter();
        this.ngControl = ngControl;
        this.changeDetector = changeDetector;
    }
    Object.defineProperty(ThfSwitchBaseComponent.prototype, "setLabelOn", {
        /**
         * @param {?} label
         * @return {?}
         */
        set: function (label) {
            this.labelOn = label || 'true';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfSwitchBaseComponent.prototype, "setLabelOff", {
        /**
         * @param {?} label
         * @return {?}
         */
        set: function (label) {
            this.labelOff = label || 'false';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfSwitchBaseComponent.prototype, "setLabelPosition", {
        /**
         * @param {?} position
         * @return {?}
         */
        set: function (position) {
            this.labelPosition = (position in ThfSwitchLabelPosition) ? position : ThfSwitchLabelPosition.Right;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfSwitchBaseComponent.prototype, "setDisabled", {
        /**
         * @param {?} disabled
         * @return {?}
         */
        set: function (disabled) {
            this.disabled = disabled === '' ? true : convertToBoolean(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThfSwitchBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = required === '' ? true : convertToBoolean(required);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.ngOnInit = function () {
        // Adicionar este componente ao ngControl, para que o formulário encontre-o
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
            if (this.required) {
                this.ngControl.control.setValidators([forms.Validators.required]);
            }
        }
    };
    /**
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.ngAfterViewChecked = function () {
        this.changeDetector.detectChanges();
    };
    /**
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.eventClick = function () {
        if (!this.disabled) {
            this.changeValue(!this.switchValue);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.changeValue = function (value) {
        if (this.switchValue !== value) {
            this.switchValue = value;
            this.change.emit(this.switchValue);
            if (this.propagateChange) {
                this.propagateChange(value);
            }
            else {
                this.ngModelChange.emit(value);
            }
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.writeValue = function (value) {
        if (value !== this.switchValue) {
            this.switchValue = !!value;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfSwitchBaseComponent.prototype.registerOnTouched = function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @nocollapse
     */
    ThfSwitchBaseComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef, },
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfSwitchBaseComponent.propDecorators = {
        'name': [{ type: core.Input, args: ['name',] },],
        'label': [{ type: core.Input, args: ['t-label',] },],
        'help': [{ type: core.Input, args: ['t-help',] },],
        'setLabelOn': [{ type: core.Input, args: ['t-label-on',] },],
        'setLabelOff': [{ type: core.Input, args: ['t-label-off',] },],
        'setLabelPosition': [{ type: core.Input, args: ['t-label-position',] },],
        'setDisabled': [{ type: core.Input, args: ['t-disabled',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'change': [{ type: core.Output, args: ['t-change',] },],
        'ngModelChange': [{ type: core.Output, args: ['ngModelChange',] },],
    };
    return ThfSwitchBaseComponent;
}());

/**
 * \@description
 *
 * O componente thf-upload permite que o usuário envie arquivo(s) ao servidor e acompanhe o progresso.
 * Este componente também possibilita algumas configurações como:
 *  - Múltipla seleção, onde o usuário pode enviar mais de um arquivo ao servidor.
 *  - Auto envio, onde o arquivo é enviado imediatamente após a seleção do usuário, não necessitando que o usuário
 * clique em enviar.
 *  - Restrições de formatos de arquivo e tamanho.
 *  - Função de sucesso que será disparada quando os arquivos forem enviados com sucesso.
 *  - Função de erro que será disparada quando houver erro no envio dos arquivos.
 * @abstract
 */
var ThfUploadBaseComponent = (function () {
    /**
     * @param {?=} ngControl
     */
    function ThfUploadBaseComponent(ngControl) {
        /**
         * Define o valor do atributo name do componente.
         */
        this.name = 'file';
        /**
         * Indica que o campo será desabilitado
         */
        this.disabled = false;
        /**
         * Define se o envio do arquivo será automático ao selecionar o mesmo.
         */
        this.autoUpload = false;
        /**
         * Define o ID para o componente.
         */
        this.id = 'file';
        /**
         * Função que será executada no momento de realizar o envio do arquivo,
         * onde será possível adicionar informações ao parâmetro que será enviado na requisição.
         * É passado por parâmetro um objeto com o arquivo e a propiedade data nesta propriedade pode ser informado algum dado,
         * que será enviado em conjunto com o arquivo na requisição.
         * Por exemplo:
         * event.data = {id: 'id do usuario'};
         */
        this.onUpload = new core.EventEmitter();
        /**
         * Evento será disparado quando ocorrer algum erro no envio do arquivo.
         * Por parâmetro será passado o objeto do retorno que é do tipo HttpErrorResponse.
         */
        this.onError = new core.EventEmitter();
        /**
         * Evento será disparado quando o envio do arquivo for realizado com sucesso.
         * Por parâmetro será passado o objeto do retorno que é do tipo HttpResponse.
         */
        this.onSuccess = new core.EventEmitter();
        // Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
        this.ngModelChange = new core.EventEmitter();
        this.ngControl = ngControl;
    }
    Object.defineProperty(ThfUploadBaseComponent.prototype, "setRequired", {
        /**
         * @param {?} required
         * @return {?}
         */
        set: function (required) {
            this.required = required === '' ? false : convertToBoolean(required);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.ngOnInit = function () {
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    };
    /**
     * @abstract
     * @param {?} event
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.onFileChange = function (event) { };
    /**
     * @abstract
     * @param {?=} files
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.uploadFiles = function (files) { };
    /**
     * @abstract
     * @param {?} file
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.stopUpload = function (file) { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.updateModel = function (value) { };
    /**
     * @abstract
     * @param {?} model
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.writeValue = function (model) { };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.registerOnChange = function (fn) {
        this.onModelChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ThfUploadBaseComponent.prototype.registerOnTouched = function (fn) {
        this.onModelTouched = fn;
    };
    /**
     * @nocollapse
     */
    ThfUploadBaseComponent.ctorParameters = function () { return [
        { type: forms.NgControl, decorators: [{ type: core.Optional },] },
    ]; };
    ThfUploadBaseComponent.propDecorators = {
        'label': [{ type: core.Input, args: ['t-label',] },],
        'help': [{ type: core.Input, args: ['t-help',] },],
        'url': [{ type: core.Input, args: ['t-url',] },],
        'fileRestrictions': [{ type: core.Input, args: ['t-restrictions',] },],
        'name': [{ type: core.Input, args: ['name',] },],
        'disabled': [{ type: core.Input, args: ['t-disabled',] },],
        'autoUpload': [{ type: core.Input, args: ['t-auto-upload',] },],
        'id': [{ type: core.Input, args: ['t-id',] },],
        'isMultiple': [{ type: core.Input, args: ['t-multiple',] },],
        'setRequired': [{ type: core.Input, args: ['t-required',] },],
        'onUpload': [{ type: core.Output, args: ['t-upload',] },],
        'onError': [{ type: core.Output, args: ['t-error',] },],
        'onSuccess': [{ type: core.Output, args: ['t-success',] },],
        'ngModelChange': [{ type: core.Output, args: ['ngModelChange',] },],
    };
    return ThfUploadBaseComponent;
}());

var ThfUploadBaseService = (function () {
    /**
     * @param {?} http
     */
    function ThfUploadBaseService(http$$1) {
        this.http = http$$1;
        this.requests = [];
    }
    /**
     * Metódo responsável por enviar os arquivos ao servidor, conforme o parametro URL.
     *
     * @param {?} url URL da requisição a ser efetuada.
     * @param {?} files Arquivos a serem enviados.
     * @param {?} tOnUpload Função a ser executada quando o arquivo for enviado ao servidor.
     * @param {?} uploadCallback Função que será executada enquanto os arquivos estiverem sendo enviados.
     * @param {?} successCallback Função a ser executada quando a requisição for efetuada com sucesso.
     * @param {?} errorCallback Função a ser executada quando a requisição foi efetuada com sucesso.
     * @return {?}
     */
    ThfUploadBaseService.prototype.upload = function (url, files, tOnUpload, uploadCallback, successCallback, errorCallback) {
        var /** @type {?} */ filesLength = files.length;
        var /** @type {?} */ uploadEvent = {
            data: {},
            file: null
        };
        for (var /** @type {?} */ i = 0; i < filesLength; i++) {
            var /** @type {?} */ formData = new FormData();
            var /** @type {?} */ file = files[i];
            formData.append('files', file.rawFile);
            // Função upload, onde o desenvolvedor pode enviar dados para a requisição.
            if (tOnUpload) {
                uploadEvent['file'] = file;
                tOnUpload.emit(uploadEvent);
                formData.append('data', JSON.stringify(uploadEvent.data));
            }
            this.sendFile(url, file, formData, uploadCallback, successCallback, errorCallback);
        }
    };
    /**
     * @param {?} url
     * @param {?} file
     * @param {?} formData
     * @param {?} uploadCallback
     * @param {?} successCallback
     * @param {?} errorCallback
     * @return {?}
     */
    ThfUploadBaseService.prototype.sendFile = function (url, file, formData, uploadCallback, successCallback, errorCallback) {
        var _this = this;
        var /** @type {?} */ request = this.getRequest(url, formData).subscribe(function (event) {
            if (event.type === http.HttpEventType.UploadProgress) {
                _this.addRequest(file, request);
                var /** @type {?} */ percentDone = Math.round(100 * event.loaded / event.total);
                uploadCallback(file, percentDone);
            }
            else if (event instanceof http.HttpResponse) {
                // Sucesso, arquivos enviados.
                successCallback(file, event);
            }
        }, function (err) {
            errorCallback(file, err);
        });
    };
    /**
     * @param {?} url
     * @param {?} formData
     * @return {?}
     */
    ThfUploadBaseService.prototype.getRequest = function (url, formData) {
        var /** @type {?} */ req = new http.HttpRequest('POST', url, formData, {
            reportProgress: true
        });
        return this.http.request(req);
    };
    /**
     * @param {?} file
     * @param {?} callback
     * @return {?}
     */
    ThfUploadBaseService.prototype.stopRequestByFile = function (file, callback) {
        var /** @type {?} */ requestObj = this.requests.find(function (req) {
            return req.file.uid === file.uid;
        });
        if (requestObj) {
            var /** @type {?} */ request = requestObj.request;
            request.unsubscribe();
            this.removeRequest(requestObj);
            callback();
        }
    };
    /**
     * @param {?} requestObj
     * @return {?}
     */
    ThfUploadBaseService.prototype.removeRequest = function (requestObj) {
        var /** @type {?} */ index = this.requests.indexOf(requestObj);
        this.requests.splice(index, 1);
    };
    /**
     * @param {?} file
     * @param {?} request
     * @return {?}
     */
    ThfUploadBaseService.prototype.addRequest = function (file, request) {
        var /** @type {?} */ hasRequest = this.requests.some(function (req) {
            return req.file.uid === file.uid;
        });
        if (!hasRequest) {
            this.requests.push({ file: file, request: request });
        }
    };
    ThfUploadBaseService.decorators = [
        { type: core.Injectable },
    ];
    /**
     * @nocollapse
     */
    ThfUploadBaseService.ctorParameters = function () { return [
        { type: http.HttpClient, },
    ]; };
    return ThfUploadBaseService;
}());

var ThfUploadStatus = {};
ThfUploadStatus.Uploaded = 0;
ThfUploadStatus.Uploading = 1;
ThfUploadStatus.Error = 2;
ThfUploadStatus.None = 3;
ThfUploadStatus[ThfUploadStatus.Uploaded] = "Uploaded";
ThfUploadStatus[ThfUploadStatus.Uploading] = "Uploading";
ThfUploadStatus[ThfUploadStatus.Error] = "Error";
ThfUploadStatus[ThfUploadStatus.None] = "None";

var ThfUploadFile = (function () {
    /**
     * @param {?} file
     */
    function ThfUploadFile(file) {
        if (file) {
            this.name = file.name;
            this.extension = this.getExtension(file.name);
            this.size = file.size;
            this.rawFile = file;
            this.uid = this.generateUUID();
            this.status = ThfUploadStatus.None;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ThfUploadFile.prototype.getExtension = function (value) {
        if (value) {
            var /** @type {?} */ extension = value.substr(value.lastIndexOf('.'));
            return extension.toLowerCase();
        }
        return '';
    };
    /**
     * @return {?}
     */
    ThfUploadFile.prototype.generateUUID = function () {
        /**
         * @return {?}
         */
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    };
    return ThfUploadFile;
}());

exports.ThfCheckboxGroupBaseComponent = ThfCheckboxGroupBaseComponent;
exports.ThfDatepickerBaseComponent = ThfDatepickerBaseComponent;
exports.ThfInputBaseComponent = ThfInputBaseComponent;
exports.ThfMask = ThfMask;
exports.ThfRadioGroupBaseComponent = ThfRadioGroupBaseComponent;
exports.ThfSelectBaseComponent = ThfSelectBaseComponent;
exports.ThfSwitchBaseComponent = ThfSwitchBaseComponent;
exports.ThfSwitchLabelPosition = ThfSwitchLabelPosition;
exports.ThfUploadBaseComponent = ThfUploadBaseComponent;
exports.ThfUploadBaseService = ThfUploadBaseService;
exports.ThfUploadFile = ThfUploadFile;
exports.ThfUploadStatus = ThfUploadStatus;

Object.defineProperty(exports, '__esModule', { value: true });

})));
