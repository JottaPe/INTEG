var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Component, EventEmitter, Input, Output, ViewChild, ViewContainerRef, ViewEncapsulation, Renderer2 } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';
import { GridComponent } from '@progress/kendo-angular-grid';
import { process } from '@progress/kendo-data-query';
import { orderBy } from '@progress/kendo-data-query';
import { ThfGridBaseComponent } from '@totvs/thf-core/components/thf-grid-base/thf-grid-base.component';
/**
 *
 * \@description
 *
 * Para o correto funcionamento do THF Grid deve ser importado o módulo `BrowserAnimationsModule` no módulo principal da sua aplicação.
 *
 * > Módulo da sua aplicação:
 *
 * ```
 * import { BrowserAnimationsModule } from '\@angular/platform-browser/animations';
 *
 * ...
 *
 * \@NgModule({
 *   imports: [
 *     BrowserModule,
 *     BrowserAnimationsModule,
 *     ...
 *     ThfModule,
 *     ...
 *   ],
 *   declarations: [
 *     AppComponent
 *   ],
 *   providers: [],
 *   bootstrap: [AppComponent]
 * })
 * export class AppModule { }
 * ```
 *
 * No arquivo `angular-cli.json` da sua aplicação deve ser importado o arquivo `all.css`, que pertence ao
 * pacote `\@progress/kendo-theme-default`.
 *
 * > Arquivo .angular-cli.json:
 *
 * ```
 * ...
 * "styles": [
 *   "../node_modules/\@progress/kendo-theme-default/dist/all.css"
 * ]
 * ...
 * ```
 *
 * \@example
 * <example name="thf-grid" title="Totvs Grid Labs">
 *  <file name='sample-thf-grid.component.html'> </file>
 *  <file name='sample-thf-grid.component.ts'> </file>
 * </example>
 */
var ThfGridComponent = (function (_super) {
    __extends(ThfGridComponent, _super);
    /**
     * @param {?} viewRef
     * @param {?} renderer
     */
    function ThfGridComponent(viewRef, renderer) {
        var _this = _super.call(this) || this;
        _this.viewRef = viewRef;
        _this.renderer = renderer;
        /**
         * Habilita a opção de ordenação dos dados nas colunas.
         */
        _this.sortable = false;
        /**
         * Habilita a opção de selecionar uma linha do grid
         */
        _this.selectable = false;
        /**
         * Habilita o botão para edição da coluna.
         */
        _this.editable = false;
        /**
         * Habilita a opção para agrupamento permitindo agrupar no máximo dois níveis.
         */
        _this.groupable = false;
        /**
         * Habilita a opção para exportação dos dados.
         */
        _this.exportButtons = false;
        /**
         * Recebe valores "true" ou "false" para habilitar ou desabilitar o botão "Carregar Mais Resultados"
         */
        _this.showMoreDisabled = 'false';
        /**
         * Habilita o botão "Remover" permitindo que o usuário possa remover uma linha do grid.
         */
        _this.showRemoveButton = false;
        /**
         * Habilita o botão para adicionar linhas
         */
        _this.addButton = false;
        /**
         * Habilita um botão "Carregar mais resultados" com evento de clique que chama um método do componente.
         */
        _this.showMore = new EventEmitter();
        /**
         * Evento de seleção de linha que chama um método do componente. Este atributo é utilizado em conjunto com o atributo "t-selectable".
         */
        _this.selectionChange = new EventEmitter();
        /**
         * Evento disparado ao salvar dados do modo de edição inline, contém o modelo que foi alterado.
         */
        _this.saveValue = new EventEmitter();
        _this.editedRowIndex = -1;
        _this.groups = [];
        _this.state = { skip: 0 };
        _this.sort = [];
        _this.addButtonCalled = false;
        _this.isCancelling = false;
        _this._parentRef = viewRef['_view']['component'];
        _this.allData = _this.allData.bind(_this);
        return _this;
    }
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.listen('document', 'click', function (_a) {
            var target = _a.target;
            _this.validateSaveEventInDocument(target);
        });
        if (!this.data) {
            this.data = [];
        }
        if (!this.columns) {
            this.columns = [];
        }
        else {
            this.defineColumnType();
        }
        if (this.sortable) {
            this.sortableObject = {
                allowUnsort: this.sortable,
                mode: 'single'
            };
        }
        if (this.groupable) {
            var /** @type {?} */ arraySize = this.columns.length;
            for (var /** @type {?} */ count = 0; count < arraySize; count++) {
                var /** @type {?} */ columnTemp = this.columns[count];
                if (this.groups.length < 2 && columnTemp.groupHeader) {
                    this.groups.push({ field: columnTemp.column });
                }
            }
            this.sortableObject = null;
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
        if (!this.editable) {
            this.grid = null;
        }
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.defineColumnType = function () {
        var /** @type {?} */ lookupTableType = {
            number: function (column) {
                column.type = 'numeric';
                column.format = undefined;
            },
            currency: function (column) {
                column.type = 'numeric';
                column.format = '{0:c}';
            },
            date: function (column) {
                column.type = 'date';
                if (column.format && column.format.trim().length > 0) {
                    column.format = "{0:" + column.format + "}";
                }
                else {
                    column.format = '{0:dd/MM/yyyy}';
                }
            },
            string: function (column) {
                column.type = 'text';
                column.format = undefined;
            }
        };
        this.columns.forEach(function (column) {
            if (column.type && lookupTableType.hasOwnProperty(column.type.trim().toLowerCase())) {
                lookupTableType[column.type.trim().toLowerCase()](column);
            }
            else {
                column.type = 'text';
            }
        });
    };
    /**
     * @param {?} el
     * @param {?} className
     * @return {?}
     */
    ThfGridComponent.prototype.isChildOf = function (el, className) {
        while (el && el.parentElement) {
            if (this.hasClass(el.parentElement, className)) {
                return true;
            }
            el = el.parentElement;
        }
        return false;
    };
    /**
     * @param {?} el
     * @param {?} className
     * @return {?}
     */
    ThfGridComponent.prototype.hasClass = function (el, className) {
        return new RegExp(className).test(el.className);
    };
    /**
     * @param {?} target
     * @return {?}
     */
    ThfGridComponent.prototype.validateSaveEventInDocument = function (target) {
        if (!this.isChildOf(target, 'k-grid-content') && !this.isChildOf(target, 'k-grid-toolbar')) {
            this.saveClick();
        }
    };
    /**
     * @param {?} sort
     * @return {?}
     */
    ThfGridComponent.prototype.sortChange = function (sort) {
        this.sort = sort;
        this.loadData();
    };
    /**
     * @param {?} state
     * @return {?}
     */
    ThfGridComponent.prototype.dataStateChange = function (state) {
        // Esta condição foi realizada para não deixar adicionar mais de 2 grupos devido
        // a um problema no kendo grid. Ja tem um chamado aberto para este problema.
        if (state.group.length > 2) {
            state.group.splice(0, 1);
        }
        this.state = state;
        this.gridView = process(this.data, this.state);
    };
    /**
     * @param {?} dataUpdated
     * @return {?}
     */
    ThfGridComponent.prototype.updateIndex = function (dataUpdated) {
        // A variavel "this.data" é a fonte de dados principal,
        // na linha abaixo eu estou atualizando a fonte de dados
        // principal com a fonte de dados ordenada para os indices
        // não se perderem na hora de salvar uma edição.
        for (var /** @type {?} */ i = 0, /** @type {?} */ dataLength = dataUpdated.length; i < dataLength; i++) {
            this.data[i] = dataUpdated[i];
        }
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.loadData = function () {
        // A variavel "this.data" é a fonte de dados principal,
        // na linha abaixo eu estou atualizando a fonte de dados
        // principal com a fonte de dados ordenada para os indices
        // não se perderem na hora de salvar uma edição.
        this.updateIndex(orderBy(this.data, this.sort));
        this.gridView = {
            data: this.data,
            total: this.data.length
        };
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.createFormGroup = function () {
        var /** @type {?} */ group = {};
        for (var /** @type {?} */ count = 0; count < this.columns.length; count++) {
            var /** @type {?} */ columnTemp = this.columns[count];
            if (!columnTemp.checkbox) {
                if (columnTemp.required) {
                    group[columnTemp.column] = new FormControl('', Validators.required);
                }
                else {
                    group[columnTemp.column] = new FormControl('');
                }
            }
        }
        this.formGroup = new FormGroup(group);
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.addHandler = function (_a) {
        var sender = _a.sender;
        if (this.editedRowIndex >= 0) {
            this.closeEditor(sender, this.editedRowIndex);
        }
        this.addButtonCalled = true;
        this.createFormGroup();
        if (this.addAction) {
            if (this.executeFunctionValidation(this.addAction, this.formGroup.value)) {
                this.formGroup.setValue(this.formGroup.value);
            }
            else {
                return;
            }
        }
        sender.addRow(this.formGroup);
    };
    /**
     * @param {?} func
     * @param {?} param
     * @return {?}
     */
    ThfGridComponent.prototype.executeFunctionValidation = function (func, param) {
        return (func && this._parentRef[func](param));
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.saveLine = function () {
        if (this.editable) {
            var /** @type {?} */ newRowValue = void 0;
            if (this.editedRowIndex >= 0) {
                newRowValue = Object.assign(this.data[this.editedRowIndex], this.formGroup.value);
                this.data[this.editedRowIndex] = newRowValue;
            }
            else if (this.addButtonCalled && this.formGroup) {
                newRowValue = this.formGroup.value;
                this.data.push(newRowValue);
                this.addButtonCalled = false;
            }
            if (this.isGroup()) {
                this.loadDataGroupable();
            }
            this.saveValue.emit({ data: newRowValue });
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.editClickHandler = function (_a) {
        var rowIndex = _a.rowIndex, dataItem = _a.dataItem;
        if (this.isValidForm()) {
            return;
        }
        if (this.executeFunctionValidation(this.saveAction, { data: this.data[this.editedRowIndex] })) {
            this.saveLine();
        }
        // Verifica se está utilizando agrupamento e busca o indice atualizado
        // do objeto que está sendo editado no momento.
        if (this.isGroup()) {
            rowIndex = this.getRowIndex(this.data, dataItem);
        }
        this.editHandler({
            sender: this.grid,
            rowIndex: rowIndex,
            dataItem: dataItem
        });
    };
    /**
     * @param {?} arr
     * @param {?} searchFor
     * @return {?}
     */
    ThfGridComponent.prototype.getRowIndex = function (arr, searchFor) {
        var /** @type {?} */ keys = Object.keys(searchFor);
        for (var /** @type {?} */ i = 0; i < arr.length; i++) {
            var /** @type {?} */ isEqual = true;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                if (arr[i][key] !== searchFor[key]) {
                    isEqual = false;
                    break;
                }
            }
            if (isEqual) {
                return i;
            }
        }
        return -1;
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.editHandler = function (_a) {
        var sender = _a.sender, rowIndex = _a.rowIndex, dataItem = _a.dataItem;
        if (!this.editable) {
            return;
        }
        this.closeEditor(sender);
        this.editedProducted = Object.assign({}, dataItem);
        this.formGroup = new FormGroup({});
        for (var _i = 0, _b = Object.keys(dataItem); _i < _b.length; _i++) {
            var key = _b[_i];
            var /** @type {?} */ control = void 0;
            var /** @type {?} */ columnTemp = this.getColumn(key);
            if (columnTemp && columnTemp.editable) {
                if (columnTemp.required) {
                    control = new FormControl(dataItem[key], Validators.required);
                }
                else {
                    control = new FormControl(dataItem[key]);
                }
                this.formGroup.addControl(key, control);
            }
        }
        this.editedRowIndex = rowIndex;
        sender.editRow(rowIndex, this.formGroup);
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.saveClick = function () {
        if (this.addButtonCalled && this.saveAction && this.formGroup) {
            if (!this.executeFunctionValidation(this.saveAction, { data: this.formGroup.value })) {
                return;
            }
        }
        else if (this.editedRowIndex >= 0 && this.saveAction) {
            if (!this.executeFunctionValidation(this.saveAction, { data: this.data[this.editedRowIndex] })) {
                this.closeEditor(this.grid, this.editedRowIndex);
                return;
            }
        }
        if (this.isValidForm()) {
            return;
        }
        this.saveLine();
        this.closeEditor(this.grid);
        if (this.isGroup()) {
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.isGroup = function () {
        return (this.groups && this.groups.length > 0);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    ThfGridComponent.prototype.getColumn = function (key) {
        for (var /** @type {?} */ index = 0; index < this.columns.length; index++) {
            var /** @type {?} */ element = this.columns[index];
            if (element.column === key) {
                return element;
            }
        }
    };
    /**
     * @param {?} grid
     * @param {?=} rowIndex
     * @return {?}
     */
    ThfGridComponent.prototype.closeEditor = function (grid, rowIndex) {
        rowIndex = this.editedRowIndex;
        if (grid) {
            grid.closeRow(rowIndex);
        }
        this.editedRowIndex = undefined;
        this.formGroup = undefined;
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.saveHandler = function (_a) {
        var sender = _a.sender, rowIndex = _a.rowIndex, formGroup = _a.formGroup, isNew = _a.isNew;
        var /** @type {?} */ item = formGroup.value;
        if (isNew && !this.editable) {
            this.data.push(item);
        }
        else {
            this.data[rowIndex] = Object.assign(this.data[rowIndex], item);
        }
        if (this.isGroup()) {
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
        sender.closeRow(rowIndex);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ThfGridComponent.prototype.cancelPropagation = function (event) {
        event.stopPropagation();
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.cancelHandler = function (_a) {
        var sender = _a.sender, rowIndex = _a.rowIndex;
        if (this.editedProducted != null) {
            this.data[rowIndex] = this.editedProducted;
            this.editedProducted = null;
        }
        if (this.isGroup()) {
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
        this.closeEditor(sender);
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    ThfGridComponent.prototype.removeHandler = function (_a) {
        var rowIndex = _a.rowIndex;
        if (this.removeAction) {
            if (!this.executeFunctionValidation(this.removeAction, { data: this.data[rowIndex] })) {
                return;
            }
        }
        this.data.splice(rowIndex, 1);
        if (this.groupable) {
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.isValidForm = function () {
        return (this.formGroup && !this.formGroup.valid);
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.allData = function () {
        var /** @type {?} */ result = {
            data: process(this.data, {}).data
        };
        return result;
    };
    /**
     * @param {?} event
     * @param {?} index
     * @param {?} data
     * @param {?} column
     * @return {?}
     */
    ThfGridComponent.prototype.changeValueCheckbox = function (event, index, data, column) {
        if (!this.editable) {
            event.target.checked = !event.target.checked;
            return;
        }
        data[column] = event.target.checked;
        this.data[index] = Object.assign(data);
        this.saveValue.emit({ data: this.data[index] });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ThfGridComponent.prototype.onSelectionChange = function (e) {
        this.selectionChange.emit({ data: this.gridView.data[e.index] });
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.onShowMore = function () {
        this.showMore.emit(null);
        if (this.groupable) {
            this.loadDataGroupable();
        }
        else {
            this.loadData();
        }
    };
    /**
     * @param {?} groups
     * @return {?}
     */
    ThfGridComponent.prototype.groupChange = function (groups) {
        this.groups = groups;
        this.loadDataGroupable();
    };
    /**
     * @return {?}
     */
    ThfGridComponent.prototype.loadDataGroupable = function () {
        this.gridView = process(this.data, { group: this.groups });
        this.dataArrayOrdered = [];
        this.getObjects(this.gridView.data);
        this.updateIndex(this.dataArrayOrdered);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ThfGridComponent.prototype.getObjects = function (data) {
        var _this = this;
        data.forEach(function (value) {
            if (value.items instanceof Array) {
                _this.getObjects(value.items);
            }
            else {
                _this.dataArrayOrdered.push(value);
            }
        });
    };
    ThfGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'thf-grid',
                    encapsulation: ViewEncapsulation.None, template: "<kendo-grid  [data]=\"gridView\"  [sortable]=\"sortableObject\" [sort]=\"sort\" [groupable]=\"groupable\" [group]=\"groups\" [selectable]=\"selectable\" (dataStateChange)=\"dataStateChange($event)\" (groupChange)=\"groupChange($event)\" (selectionChange)=\"onSelectionChange($event)\" (sortChange)=\"sortChange($event)\" (add)=\"addHandler($event)\" (cancel)=\"cancelHandler($event)\" (cellClick)=\"editClickHandler($event)\" (edit)=\"editHandler($event)\" (remove)=\"removeHandler($event)\" (save)=\"saveHandler($event)\" style=\"height: 70%\"> <kendo-grid-messages  i18n-noRecords=\"\" noRecords=\"Não há registros\" i18n-groupPanelEmpty=\"\" groupPanelEmpty=\"Arraste a coluna até o cabeçalho e solte para agrupar por esta coluna\"> </kendo-grid-messages> <ng-template kendoGridToolbarTemplate *ngIf=\"addButton || exportButtons\" > <button kendoGridAddCommand *ngIf=\"addButton\" class=\"k-primary\">Adicionar</button> <button type=\"button\" kendoGridExcelCommand *ngIf=\"exportButtons\" ><span class=\"k-icon k-i-file-excel\"></span></button> <button kendoGridPDFCommand *ngIf=\"exportButtons\"><span class='k-icon k-i-file-pdf'></span></button> </ng-template> <kendo-grid-column *ngFor=\"let col of columns; let i = index\" [field]=\"col.column\" [title]=\"col.label\" [width]=\"col.width\" [filter]=\"col.filter\" [format]=\"col.format\" [editor]=\"col.type\"> <ng-template kendoGridCellTemplate let-data *ngIf=\"col.checkbox\" let-rowIndex=\"rowIndex\"> <input type=\"checkbox\" id=\"chkbox_{{rowIndex}}\" name=\"chkbox_{{col.column}}_{{rowIndex}}\" [checked]=\"data[col.column]\" (change)=\"changeValueCheckbox($event, rowIndex, data, col.column)\" class=\"thf-grid thf-grid-checkbox\" /> <label for=\"chkbox_{{rowIndex}}\"></label> </ng-template> <ng-template kendoGridGroupHeaderTemplate let-value=\"value\" *ngIf=\"col.groupHeader\"> {{value}} </ng-template> </kendo-grid-column> <kendo-grid-command-column title=\"\" width=\"80\"> <ng-template kendoGridCellTemplate let-isNew=\"isNew\"> <button kendoGridRemoveCommand class=\"k-primary\" *ngIf=\"showRemoveButton\" >Remover</button> <button kendoGridCancelCommand class=\"k-primary\" (click)=\"cancelPropagation($event)\">{{ isNew ? 'Descartar' : 'Cancelar' }} </button> </ng-template> </kendo-grid-command-column> <kendo-grid-excel fileName=\"spreadsheet.xlsx\" [fetchData]=\"allData\"></kendo-grid-excel> <kendo-grid-pdf fileName=\"grid.pdf\" [allPages]=\"true\"> <kendo-grid-pdf-margin top=\"1cm\" left=\"1cm\" right=\"1cm\" bottom=\"1cm\"></kendo-grid-pdf-margin> </kendo-grid-pdf> </kendo-grid> <div class=\"thf-grid-show-more\" *ngIf=\"showMore.observers.length > 0\"> <div style=\"text-align: center;\"> <thf-button t-label=\"Carregar mais resultados\" (t-click)=\"onShowMore()\" t-id=\"btnShowMoreId\" [t-disabled]=\"showMoreDisabled\"></thf-button> </div> </div> ", styles: [".k-grid .k-state-selected { background-color: skyblue !important; color: #000000; } .k-grid .k-alt.k-state-selected { background-color: skyblue !important; color: #000000; } .thf-grid.thf-grid-checkbox { width: 20px; height: 20px; border-radius: 2px; box-shadow: inset 0 1px 8px 0 rgba(0, 0, 0, 0.1); border: solid 1px rgba(255, 255, 255, 0.6); } .thf-grid.thf-grid-checkbox:checked { width: 20px; height: 20px; border-radius: 2px; } input[type=checkbox] { visibility: hidden; position: absolute; } input[type=checkbox] + label:before { width: 20px; height: 20px; margin-top: -2px; margin-right: 8px; display: inline-block; vertical-align: middle; background-color: #ffffff; box-shadow: inset 0px 2px 8px 0 #edefef; border: solid 1px #b7bebf; content: ' '; } input[type=checkbox]:checked + label:before { background-color: #0c9abe; box-shadow: none; color: white; font-family: 'TotvsIcon' !important; line-height: 18px; content: '\\e937'; padding-left: 1px; } input[type=checkbox]:disabled + label:before { background-color: #edefef; border: solid 1px #b7bebf; } input[type=checkbox]:checked:disabled + label:before { color: #b7bebf; border: solid 1px #b6bdbf; } input[type=checkbox] + label:before { border-radius: 2px; } .thf-grid-show-more { width: 100%; margin-top: 10px; margin-bottom: 10px; } "]
                },] },
    ];
    /**
     * @nocollapse
     */
    ThfGridComponent.ctorParameters = function () { return [
        { type: ViewContainerRef, },
        { type: Renderer2, },
    ]; };
    ThfGridComponent.propDecorators = {
        'columns': [{ type: Input, args: ['t-columns',] },],
        'sortable': [{ type: Input, args: ['t-sortable',] },],
        'selectable': [{ type: Input, args: ['t-selectable',] },],
        'editable': [{ type: Input, args: ['t-editable',] },],
        'groupable': [{ type: Input, args: ['t-groupable',] },],
        'exportButtons': [{ type: Input, args: ['t-show-export-buttons',] },],
        'showMoreDisabled': [{ type: Input, args: ['t-show-more-disabled',] },],
        'showRemoveButton': [{ type: Input, args: ['t-show-remove-button',] },],
        'addButton': [{ type: Input, args: ['t-show-add-button',] },],
        'saveAction': [{ type: Input, args: ['t-save-action',] },],
        'removeAction': [{ type: Input, args: ['t-remove-action',] },],
        'addAction': [{ type: Input, args: ['t-add-action',] },],
        'showMore': [{ type: Output, args: ['t-show-more',] },],
        'selectionChange': [{ type: Output, args: ['t-selection-change',] },],
        'saveValue': [{ type: Output, args: ['t-save-value',] },],
        'grid': [{ type: ViewChild, args: [GridComponent,] },],
    };
    return ThfGridComponent;
}(ThfGridBaseComponent));
export { ThfGridComponent };
function ThfGridComponent_tsickle_Closure_declarations() {
    /** @type {?} */
    ThfGridComponent.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    ThfGridComponent.ctorParameters;
    /** @type {?} */
    ThfGridComponent.propDecorators;
    /**
     * Objeto com as informações das colunas a serem exibidas.
     * @type {?}
     */
    ThfGridComponent.prototype.columns;
    /**
     * Habilita a opção de ordenação dos dados nas colunas.
     * @type {?}
     */
    ThfGridComponent.prototype.sortable;
    /**
     * Habilita a opção de selecionar uma linha do grid
     * @type {?}
     */
    ThfGridComponent.prototype.selectable;
    /**
     * Habilita o botão para edição da coluna.
     * @type {?}
     */
    ThfGridComponent.prototype.editable;
    /**
     * Habilita a opção para agrupamento permitindo agrupar no máximo dois níveis.
     * @type {?}
     */
    ThfGridComponent.prototype.groupable;
    /**
     * Habilita a opção para exportação dos dados.
     * @type {?}
     */
    ThfGridComponent.prototype.exportButtons;
    /**
     * Recebe valores "true" ou "false" para habilitar ou desabilitar o botão "Carregar Mais Resultados"
     * @type {?}
     */
    ThfGridComponent.prototype.showMoreDisabled;
    /**
     * Habilita o botão "Remover" permitindo que o usuário possa remover uma linha do grid.
     * @type {?}
     */
    ThfGridComponent.prototype.showRemoveButton;
    /**
     * Habilita o botão para adicionar linhas
     * @type {?}
     */
    ThfGridComponent.prototype.addButton;
    /**
     * Executa um método antes de salvar uma linha editada no thf-grid. Este método recebe como parâmetro o atributo *event*,
     * para acessar o objeto selecionado no thf-grid utilizando o *event.data*.
     *  Se o método retornar o valor booleano *true*, a edição da linha é confirmada,
     * caso contrário as informações alteradas serão canceladas.
     * @type {?}
     */
    ThfGridComponent.prototype.saveAction;
    /**
     * Executa um método antes de remover uma linha selecionada no thf-grid. Este método recebe como parâmetro o atributo *event*,
     * para acessar o objeto selecionado no thf-grid utilizando o *event.data*.
     *  Se o método retornar o valor booleano *true*, a remoção da linha é confirmada,
     * caso contrário as informações serão mantidas.
     * @type {?}
     */
    ThfGridComponent.prototype.removeAction;
    /**
     * Método executado antes de adicionar uma nova linha ao thf-grid.
     *
     * Esse método recebe como parâmetro o atributo *data* contendo a referência do objeto que será adicionado, dessa forma é possível
     * informar alguns valores para a nova linha, para que as alterações sejam efetivadas, deve-se retornar *true*.
     * Caso tenha necessidade, é possível cancelar a inclusão de uma nova linha retornando *false*, nesse caso as informações serão
     * descartadas e a nova linha não será incluída no thf-grid.
     * @type {?}
     */
    ThfGridComponent.prototype.addAction;
    /**
     * Habilita um botão "Carregar mais resultados" com evento de clique que chama um método do componente.
     * @type {?}
     */
    ThfGridComponent.prototype.showMore;
    /**
     * Evento de seleção de linha que chama um método do componente. Este atributo é utilizado em conjunto com o atributo "t-selectable".
     * @type {?}
     */
    ThfGridComponent.prototype.selectionChange;
    /**
     * Evento disparado ao salvar dados do modo de edição inline, contém o modelo que foi alterado.
     * @type {?}
     */
    ThfGridComponent.prototype.saveValue;
    /** @type {?} */
    ThfGridComponent.prototype._parentRef;
    /** @type {?} */
    ThfGridComponent.prototype.editedRowIndex;
    /** @type {?} */
    ThfGridComponent.prototype.editedProducted;
    /** @type {?} */
    ThfGridComponent.prototype.groups;
    /** @type {?} */
    ThfGridComponent.prototype.gridView;
    /** @type {?} */
    ThfGridComponent.prototype.state;
    /** @type {?} */
    ThfGridComponent.prototype.sortableObject;
    /** @type {?} */
    ThfGridComponent.prototype.sort;
    /** @type {?} */
    ThfGridComponent.prototype.addButtonCalled;
    /** @type {?} */
    ThfGridComponent.prototype.isCancelling;
    /** @type {?} */
    ThfGridComponent.prototype.formGroup;
    /** @type {?} */
    ThfGridComponent.prototype.dataArrayOrdered;
    /** @type {?} */
    ThfGridComponent.prototype.grid;
    /** @type {?} */
    ThfGridComponent.prototype.viewRef;
    /** @type {?} */
    ThfGridComponent.prototype.renderer;
}
